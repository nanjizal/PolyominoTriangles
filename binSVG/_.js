// Generated by Haxe 3.4.0 (git build development @ 4a40be3)
(function () { "use strict";
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
Math.__name__ = true;
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	var v = parseInt(x,10);
	if(v == 0 && (HxOverrides.cca(x,1) == 120 || HxOverrides.cca(x,1) == 88)) {
		v = parseInt(x);
	}
	if(isNaN(v)) {
		return null;
	}
	return v;
};
var StringTools = function() { };
StringTools.__name__ = true;
StringTools.hex = function(n,digits) {
	var s = "";
	while(true) {
		s = "0123456789ABCDEF".charAt(n & 15) + s;
		n >>>= 4;
		if(!(n > 0)) {
			break;
		}
	}
	if(digits != null) {
		while(s.length < digits) s = "0" + s;
	}
	return s;
};
var htmlHelper_svg__$SvgRoot_SvgRoot_$Impl_$ = {};
htmlHelper_svg__$SvgRoot_SvgRoot_$Impl_$.__name__ = true;
htmlHelper_svg__$SvgRoot_SvgRoot_$Impl_$._new = function(e) {
	var this1;
	if(e == null) {
		var svgElement = window.document.createElementNS("http://www.w3.org/2000/svg","svg");
		var element = svgElement;
		var style = element.style;
		style.paddingLeft = "0px";
		style.paddingTop = "0px";
		style.left = Std.string(0 + "px");
		style.top = Std.string(0 + "px");
		style.position = "absolute";
		window.document.body.appendChild(element);
		this1 = svgElement;
	} else {
		this1 = e;
	}
	return this1;
};
htmlHelper_svg__$SvgRoot_SvgRoot_$Impl_$.create = function() {
	var svgElement = window.document.createElementNS("http://www.w3.org/2000/svg","svg");
	var element = svgElement;
	var style = element.style;
	style.paddingLeft = "0px";
	style.paddingTop = "0px";
	style.left = Std.string(0 + "px");
	style.top = Std.string(0 + "px");
	style.position = "absolute";
	window.document.body.appendChild(element);
	return svgElement;
};
htmlHelper_svg__$SvgRoot_SvgRoot_$Impl_$.set_width = function(this1,width_) {
	this1.setAttribute("width",width_ == null ? "null" : "" + width_);
	return width_;
};
htmlHelper_svg__$SvgRoot_SvgRoot_$Impl_$.get_width = function(this1) {
	return Std.parseInt(this1.getAttribute("width"));
};
htmlHelper_svg__$SvgRoot_SvgRoot_$Impl_$.set_height = function(this1,height_) {
	this1.setAttribute("height",height_ == null ? "null" : "" + height_);
	return height_;
};
htmlHelper_svg__$SvgRoot_SvgRoot_$Impl_$.get_height = function(this1) {
	return Std.parseInt(this1.getAttribute("height"));
};
var htmlHelper_tools_AnimateTimer = function() { };
htmlHelper_tools_AnimateTimer.__name__ = true;
htmlHelper_tools_AnimateTimer.create = function() {
	if(htmlHelper_tools_AnimateTimer.s != null) {
		return;
	}
	htmlHelper_tools_AnimateTimer.s = window.document.createElement("style");
	htmlHelper_tools_AnimateTimer.s.innerHTML = "@keyframes spin { from { transform:rotate( 0deg ); } to { transform:rotate( 360deg ); } }";
	window.document.getElementsByTagName("head")[0].appendChild(htmlHelper_tools_AnimateTimer.s);
	htmlHelper_tools_AnimateTimer.s.animation = "spin 1s linear infinite";
	htmlHelper_tools_AnimateTimer.loop(60.0);
};
htmlHelper_tools_AnimateTimer.loop = function(tim) {
	window.requestAnimationFrame(htmlHelper_tools_AnimateTimer.loop);
	if(htmlHelper_tools_AnimateTimer.onFrame != null) {
		htmlHelper_tools_AnimateTimer.onFrame(htmlHelper_tools_AnimateTimer.counter);
	}
	htmlHelper_tools_AnimateTimer.counter++;
	return true;
};
htmlHelper_tools_AnimateTimer.kill = function() {
	if(htmlHelper_tools_AnimateTimer.s == null) {
		return;
	}
	window.document.getElementsByTagName("head")[0].removeChild(htmlHelper_tools_AnimateTimer.s);
	htmlHelper_tools_AnimateTimer.onFrame = null;
	htmlHelper_tools_AnimateTimer.s = null;
};
htmlHelper_tools_AnimateTimer.tween = function(t,b,e,d,f) {
	if(t > d) {
		return null;
	}
	return f(t,b,e - b,d);
};
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o instanceof Array) {
			if(o.__enum__) {
				if(o.length == 2) {
					return o[0];
				}
				var str = o[0] + "(";
				s += "\t";
				var _g1 = 2;
				var _g = o.length;
				while(_g1 < _g) {
					var i = _g1++;
					if(i != 2) {
						str += "," + js_Boot.__string_rec(o[i],s);
					} else {
						str += js_Boot.__string_rec(o[i],s);
					}
				}
				return str + ")";
			}
			var l = o.length;
			var i1;
			var str1 = "[";
			s += "\t";
			var _g11 = 0;
			var _g2 = l;
			while(_g11 < _g2) {
				var i2 = _g11++;
				str1 += (i2 > 0 ? "," : "") + js_Boot.__string_rec(o[i2],s);
			}
			str1 += "]";
			return str1;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str2 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str2.length != 2) {
			str2 += ", \n";
		}
		str2 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str2 += "\n" + s + "}";
		return str2;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var justDrawing_Surface = function(graphics_) {
	this.inFill = false;
	this.prevY = 0;
	this.prevX = 0;
	this.graphics = graphics_;
	this.inFill = false;
	this.svgShapes = [];
};
justDrawing_Surface.__name__ = true;
justDrawing_Surface.getColor = function(col,alpha) {
	var str;
	if(alpha != null && alpha != 1.0) {
		str = "rgba(" + (col >> 16 & 255) + "," + (col >> 8 & 255) + "," + (col & 255) + "," + alpha + ")";
	} else {
		str = "#" + StringTools.hex(col,6);
	}
	return str;
};
justDrawing_Surface.arcTan = function(p0,p1) {
	return Math.atan2(p1.y - p0.y,p1.x - p0.x);
};
justDrawing_Surface.distance = function(p0,p1) {
	var x = p0.x - p1.x;
	var y = p0.y - p1.y;
	return Math.sqrt(x * x + y * y);
};
justDrawing_Surface.quadraticBezier = function(t,arr) {
	var u = 1 - t;
	var u1 = 1 - t;
	return { x : Math.pow(u,2) * arr[0].x + 2 * u * t * arr[1].x + Math.pow(t,2) * arr[2].x, y : Math.pow(u1,2) * arr[0].y + 2 * u1 * t * arr[1].y + Math.pow(t,2) * arr[2].y};
};
justDrawing_Surface._quadraticBezier = function(t,startPoint,controlPoint,endPoint) {
	var u = 1 - t;
	return Math.pow(u,2) * startPoint + 2 * u * t * controlPoint + Math.pow(t,2) * endPoint;
};
justDrawing_Surface.cubicBezier = function(t,arr) {
	var u = 1 - t;
	var u1 = 1 - t;
	return { x : Math.pow(u,3) * arr[0].x + 3 * Math.pow(u,2) * t * arr[1].x + 3 * u * Math.pow(t,2) * arr[2].x + Math.pow(t,3) * arr[3].x, y : Math.pow(u1,3) * arr[0].y + 3 * Math.pow(u1,2) * t * arr[1].y + 3 * u1 * Math.pow(t,2) * arr[2].y + Math.pow(t,3) * arr[3].y};
};
justDrawing_Surface._cubicBezier = function(t,startPoint,controlPoint1,controlPoint2,endPoint) {
	var u = 1 - t;
	return Math.pow(u,3) * startPoint + 3 * Math.pow(u,2) * t * controlPoint1 + 3 * u * Math.pow(t,2) * controlPoint2 + Math.pow(t,3) * endPoint;
};
justDrawing_Surface.prototype = {
	repaint: function() {
		var _g = 0;
		var _g1 = this.svgShapes;
		while(_g < _g1.length) {
			var all = _g1[_g];
			++_g;
			this.graphics.appendChild(all);
		}
	}
	,remove: function(element) {
		if(!this.graphics.hasChildNodes()) {
			return;
		}
		this.graphics.removeChild(element);
	}
	,clear: function() {
		this.currPathD = "";
		while(this.svgShapes.length != 0) this.remove(this.svgShapes.pop());
	}
	,lineStyle: function(thick,color,alpha) {
		if(alpha == null) {
			alpha = 1.;
		}
		this.thickness = thick;
		this.lineColor = color;
		this.lineAlpha = alpha;
	}
	,beginFill: function(color,alpha) {
		this.fillColor = color;
		this.fillAlpha = alpha;
		this.inFill = true;
		this.currPathD = "";
		var svgPath = window.document.createElementNS("http://www.w3.org/2000/svg","path");
		this.svgShapes.push(svgPath);
	}
	,endFill: function() {
		this.inFill = false;
		console.log(" endFill " + this.currPathD);
		var svgPath = this.svgShapes[this.svgShapes.length - 1];
		svgPath.setAttribute("d",this.currPathD + "Z");
		var col = this.fillColor;
		var alpha = this.fillAlpha;
		var str;
		if(alpha != null && alpha != 1.0) {
			str = "rgba(" + (col >> 16 & 255) + "," + (col >> 8 & 255) + "," + (col & 255) + "," + alpha + ")";
		} else {
			str = "#" + StringTools.hex(col,6);
		}
		svgPath.setAttribute("fill",str);
		var col1 = this.lineColor;
		var alpha1 = this.lineAlpha;
		var str1;
		if(alpha1 != null && alpha1 != 1.0) {
			str1 = "rgba(" + (col1 >> 16 & 255) + "," + (col1 >> 8 & 255) + "," + (col1 & 255) + "," + alpha1 + ")";
		} else {
			str1 = "#" + StringTools.hex(col1,6);
		}
		svgPath.setAttribute("stroke",str1);
		svgPath.setAttribute("stroke-width",Std.string(this.thickness));
		this.graphics.appendChild(svgPath);
		this.currPathD = "";
	}
	,moveTo: function(x,y) {
		this.prevX = x;
		this.prevY = y;
		if(this.inFill) {
			this.currPathD += "M" + x + "," + y + " ";
		}
	}
	,lineTo: function(x,y) {
		if(this.inFill) {
			if(this.inFill) {
				this.currPathD += "" + "L" + x + "," + y + " ";
			}
		} else {
			var aLine = window.document.createElementNS("http://www.w3.org/2000/svg","line");
			aLine.setAttribute("x1",Std.string(this.prevX));
			aLine.setAttribute("y1",Std.string(this.prevY));
			aLine.setAttribute("x2",x == null ? "null" : "" + x);
			aLine.setAttribute("y2",y == null ? "null" : "" + y);
			var col = this.lineColor;
			var alpha = this.lineAlpha;
			var str;
			if(alpha != null && alpha != 1.0) {
				str = "rgba(" + (col >> 16 & 255) + "," + (col >> 8 & 255) + "," + (col & 255) + "," + alpha + ")";
			} else {
				str = "#" + StringTools.hex(col,6);
			}
			aLine.setAttribute("stroke",str);
			aLine.setAttribute("stroke-width",Std.string(this.thickness));
			this.graphics.appendChild(aLine);
			this.svgShapes.push(aLine);
		}
		this.prevX = x;
		this.prevY = y;
	}
	,curveTo: function(x1,y1,x2,y2,x3,y3) {
		var quadString = "" + "C" + x1 + "," + y1 + " " + x2 + "," + y2 + " " + x3 + "," + y3;
		if(this.inFill) {
			this.currPathD += quadString;
		} else {
			var svgPath = window.document.createElementNS("http://www.w3.org/2000/svg","path");
			svgPath.setAttribute("d",quadString + "Z");
			var col = this.lineColor;
			var alpha = this.lineAlpha;
			var str;
			if(alpha != null && alpha != 1.0) {
				str = "rgba(" + (col >> 16 & 255) + "," + (col >> 8 & 255) + "," + (col & 255) + "," + alpha + ")";
			} else {
				str = "#" + StringTools.hex(col,6);
			}
			svgPath.setAttribute("stroke",str);
			svgPath.setAttribute("stroke-width",Std.string(this.thickness));
			this.graphics.appendChild(svgPath);
			this.svgShapes.push(svgPath);
		}
	}
	,quadTo: function(cx,cy,ax,ay) {
		var quadString = "" + "Q" + cx + "," + cy + " " + ax + "," + ay + " ";
		if(this.inFill) {
			this.currPathD += quadString;
		} else {
			var svgPath = window.document.createElementNS("http://www.w3.org/2000/svg","path");
			svgPath.setAttribute("d",quadString + "Z");
			var col = this.lineColor;
			var alpha = this.lineAlpha;
			var str;
			if(alpha != null && alpha != 1.0) {
				str = "rgba(" + (col >> 16 & 255) + "," + (col >> 8 & 255) + "," + (col & 255) + "," + alpha + ")";
			} else {
				str = "#" + StringTools.hex(col,6);
			}
			svgPath.setAttribute("stroke",str);
			svgPath.setAttribute("stroke-width",Std.string(this.thickness));
			this.graphics.appendChild(svgPath);
			this.svgShapes.push(svgPath);
		}
	}
	,drawCircle: function(cx,cy,radius) {
		var svgCircle = window.document.createElementNS("http://www.w3.org/2000/svg","circle");
		svgCircle.setAttribute("cx",cx == null ? "null" : "" + cx);
		svgCircle.setAttribute("cy",cy == null ? "null" : "" + cy);
		svgCircle.setAttribute("r",radius == null ? "null" : "" + radius);
		if(this.inFill) {
			var col = this.fillColor;
			var alpha = this.fillAlpha;
			var str;
			if(alpha != null && alpha != 1.0) {
				str = "rgba(" + (col >> 16 & 255) + "," + (col >> 8 & 255) + "," + (col & 255) + "," + alpha + ")";
			} else {
				str = "#" + StringTools.hex(col,6);
			}
			svgCircle.setAttribute("fill",str);
		}
		var col1 = this.lineColor;
		var alpha1 = this.lineAlpha;
		var str1;
		if(alpha1 != null && alpha1 != 1.0) {
			str1 = "rgba(" + (col1 >> 16 & 255) + "," + (col1 >> 8 & 255) + "," + (col1 & 255) + "," + alpha1 + ")";
		} else {
			str1 = "#" + StringTools.hex(col1,6);
		}
		svgCircle.setAttribute("stroke",str1);
		svgCircle.setAttribute("stroke-width",Std.string(this.thickness));
		this.graphics.appendChild(svgCircle);
		this.svgShapes.push(svgCircle);
	}
	,drawRect: function(x,y,width,height) {
		var svgRect = window.document.createElementNS("http://www.w3.org/2000/svg","rect");
		svgRect.setAttribute("x",x == null ? "null" : "" + x);
		svgRect.setAttribute("y",y == null ? "null" : "" + y);
		svgRect.setAttribute("width",width == null ? "null" : "" + width);
		svgRect.setAttribute("height",height == null ? "null" : "" + height);
		if(this.inFill) {
			var col = this.fillColor;
			var alpha = this.fillAlpha;
			var str;
			if(alpha != null && alpha != 1.0) {
				str = "rgba(" + (col >> 16 & 255) + "," + (col >> 8 & 255) + "," + (col & 255) + "," + alpha + ")";
			} else {
				str = "#" + StringTools.hex(col,6);
			}
			svgRect.setAttribute("fill",str);
		}
		var col1 = this.lineColor;
		var alpha1 = this.lineAlpha;
		var str1;
		if(alpha1 != null && alpha1 != 1.0) {
			str1 = "rgba(" + (col1 >> 16 & 255) + "," + (col1 >> 8 & 255) + "," + (col1 & 255) + "," + alpha1 + ")";
		} else {
			str1 = "#" + StringTools.hex(col1,6);
		}
		svgRect.setAttribute("stroke",str1);
		svgRect.setAttribute("stroke-width",Std.string(this.thickness));
		this.graphics.appendChild(svgRect);
		this.svgShapes.push(svgRect);
	}
	,drawEquilaterialTri: function(x,y,radius,direction) {
		var third = Math.PI * 2 / 3;
		var points = [];
		var x1;
		var y1;
		var _g = 0;
		while(_g < 3) {
			var i = _g++;
			x1 = x + radius * Math.cos(direction + i * third);
			y1 = y + radius * Math.sin(direction + i * third);
			points.push(x1);
			points.push(y1);
		}
		this.drawTri(points);
	}
	,drawTri: function(points) {
		var aTri = window.document.createElementNS("http://www.w3.org/2000/svg","polygon");
		var pointsStr = "";
		var x1;
		var y1;
		var i = 0;
		while(i < points.length) {
			pointsStr += Std.string(points[i]) + "," + Std.string(points[i + 1]) + " ";
			i += 2;
		}
		aTri.setAttribute("points",pointsStr);
		if(this.inFill) {
			var col = this.fillColor;
			var alpha = this.fillAlpha;
			var str;
			if(alpha != null && alpha != 1.0) {
				str = "rgba(" + (col >> 16 & 255) + "," + (col >> 8 & 255) + "," + (col & 255) + "," + alpha + ")";
			} else {
				str = "#" + StringTools.hex(col,6);
			}
			aTri.setAttribute("fill",str);
		}
		var col1 = this.lineColor;
		var alpha1 = this.lineAlpha;
		var str1;
		if(alpha1 != null && alpha1 != 1.0) {
			str1 = "rgba(" + (col1 >> 16 & 255) + "," + (col1 >> 8 & 255) + "," + (col1 & 255) + "," + alpha1 + ")";
		} else {
			str1 = "#" + StringTools.hex(col1,6);
		}
		aTri.setAttribute("stroke",str1);
		aTri.setAttribute("stroke-width",Std.string(this.thickness));
		this.graphics.appendChild(aTri);
		this.svgShapes.push(aTri);
	}
};
var justTriangles_Bezier = function() { };
justTriangles_Bezier.__name__ = true;
justTriangles_Bezier.quadratic = function(t,arr) {
	var u = 1 - t;
	var u1 = 1 - t;
	return { x : Math.pow(u,2) * arr[0].x + 2 * u * t * arr[1].x + Math.pow(t,2) * arr[2].x, y : Math.pow(u1,2) * arr[0].y + 2 * u1 * t * arr[1].y + Math.pow(t,2) * arr[2].y};
};
justTriangles_Bezier._quadratic = function(t,startPoint,controlPoint,endPoint) {
	var u = 1 - t;
	return Math.pow(u,2) * startPoint + 2 * u * t * controlPoint + Math.pow(t,2) * endPoint;
};
justTriangles_Bezier.cubic = function(t,arr) {
	var u = 1 - t;
	var u1 = 1 - t;
	return { x : Math.pow(u,3) * arr[0].x + 3 * Math.pow(u,2) * t * arr[1].x + 3 * u * Math.pow(t,2) * arr[2].x + Math.pow(t,3) * arr[3].x, y : Math.pow(u1,3) * arr[0].y + 3 * Math.pow(u1,2) * t * arr[1].y + 3 * u1 * Math.pow(t,2) * arr[2].y + Math.pow(t,3) * arr[3].y};
};
justTriangles_Bezier._cubic = function(t,startPoint,controlPoint1,controlPoint2,endPoint) {
	var u = 1 - t;
	return Math.pow(u,3) * startPoint + 3 * Math.pow(u,2) * t * controlPoint1 + 3 * u * Math.pow(t,2) * controlPoint2 + Math.pow(t,3) * endPoint;
};
var justTriangles_Draw = function() {
	this.thickRatio = 1024;
};
justTriangles_Draw.__name__ = true;
justTriangles_Draw.set_thick = function(val) {
	if(val < 0) {
		val = 0.00001;
	}
	justTriangles_Draw.thickness = val / 1024;
	return justTriangles_Draw.thickness;
};
justTriangles_Draw.get_thick = function() {
	return justTriangles_Draw.thickness;
};
justTriangles_Draw.packManFill = function(id,dx,dy,radius,start,dA) {
	var centre = { x : dx, y : dy};
	var p = [];
	var angle = 0;
	var angleInc = Math.PI * 2 / 60;
	var nextAngle;
	if(dA < 0) {
		var i = -1;
		while(true) {
			angle = i * angleInc;
			--i;
			nextAngle = angle + start;
			if(angle <= dA) {
				break;
			}
			p.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
		}
	} else {
		var i1 = -1;
		while(true) {
			angle = i1 * angleInc;
			++i1;
			nextAngle = angle + start;
			if(angle >= dA + angleInc) {
				break;
			}
			p.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
		}
	}
	p.reverse();
	justTriangles_Draw.q0 = p[0];
	justTriangles_Draw.q1 = p[0];
	var draw = new justTriangles_Draw();
	draw.create2Lines(p[0],p[1],p[2],justTriangles_Draw.thickness);
	justTriangles_Draw.q0 = draw.p3;
	justTriangles_Draw.q1 = draw.p4;
	var _g1 = 1;
	var _g = p.length - 2;
	while(_g1 < _g) {
		draw.rebuildAsPoly(p[_g1++ + 2]);
		var q3 = draw.p3;
		justTriangles_Draw.drawTri(id,false,justTriangles_Draw.q0,q3,centre,justTriangles_Draw.colorId);
		justTriangles_Draw.q0 = q3;
	}
};
justTriangles_Draw.roundedRectangleOutline = function(id,dx,dy,hi,wid,radiusSmall,radius) {
	var dia = radius * 2;
	var dy1 = dy + hi;
	var start = -Math.PI - Math.PI / 2;
	var dA = Math.PI / 2;
	var p = [];
	var angle = 0;
	var angleInc = Math.PI * 2 / 120;
	var nextAngle;
	if(dA < 0) {
		var i = -1;
		while(true) {
			angle = i * angleInc;
			--i;
			nextAngle = angle + start;
			if(angle <= dA) {
				break;
			}
			p.push({ x : dx + radiusSmall * Math.cos(nextAngle), y : dy1 + radiusSmall * Math.sin(nextAngle)});
		}
	} else {
		var i1 = -1;
		while(true) {
			angle = i1 * angleInc;
			++i1;
			nextAngle = angle + start;
			if(angle >= dA + angleInc) {
				break;
			}
			p.push({ x : dx + radiusSmall * Math.cos(nextAngle), y : dy1 + radiusSmall * Math.sin(nextAngle)});
		}
	}
	p.reverse();
	var dx1 = dx + wid;
	var dy2 = dy + hi;
	var dA1 = Math.PI / 2;
	var p1 = [];
	var angle1 = 0;
	var angleInc1 = Math.PI * 2 / 120;
	var nextAngle1;
	if(dA1 < 0) {
		var i2 = -1;
		while(true) {
			angle1 = i2 * angleInc1;
			--i2;
			nextAngle1 = angle1;
			if(angle1 <= dA1) {
				break;
			}
			p1.push({ x : dx1 + radiusSmall * Math.cos(nextAngle1), y : dy2 + radiusSmall * Math.sin(nextAngle1)});
		}
	} else {
		var i3 = -1;
		while(true) {
			angle1 = i3 * angleInc1;
			++i3;
			nextAngle1 = angle1;
			if(angle1 >= dA1 + angleInc1) {
				break;
			}
			p1.push({ x : dx1 + radiusSmall * Math.cos(nextAngle1), y : dy2 + radiusSmall * Math.sin(nextAngle1)});
		}
	}
	p1.reverse();
	var dx2 = dx + wid;
	var start1 = -Math.PI / 2;
	var dA2 = Math.PI / 2;
	var p2 = [];
	var angle2 = 0;
	var angleInc2 = Math.PI * 2 / 120;
	var nextAngle2;
	if(dA2 < 0) {
		var i4 = -1;
		while(true) {
			angle2 = i4 * angleInc2;
			--i4;
			nextAngle2 = angle2 + start1;
			if(angle2 <= dA2) {
				break;
			}
			p2.push({ x : dx2 + radiusSmall * Math.cos(nextAngle2), y : dy + radiusSmall * Math.sin(nextAngle2)});
		}
	} else {
		var i5 = -1;
		while(true) {
			angle2 = i5 * angleInc2;
			++i5;
			nextAngle2 = angle2 + start1;
			if(angle2 >= dA2 + angleInc2) {
				break;
			}
			p2.push({ x : dx2 + radiusSmall * Math.cos(nextAngle2), y : dy + radiusSmall * Math.sin(nextAngle2)});
		}
	}
	p2.reverse();
	var start2 = -Math.PI;
	var dA3 = Math.PI / 2;
	var p3 = [];
	var angle3 = 0;
	var angleInc3 = Math.PI * 2 / 120;
	var nextAngle3;
	if(dA3 < 0) {
		var i6 = -1;
		while(true) {
			angle3 = i6 * angleInc3;
			--i6;
			nextAngle3 = angle3 + start2;
			if(angle3 <= dA3) {
				break;
			}
			p3.push({ x : dx + radiusSmall * Math.cos(nextAngle3), y : dy + radiusSmall * Math.sin(nextAngle3)});
		}
	} else {
		var i7 = -1;
		while(true) {
			angle3 = i7 * angleInc3;
			++i7;
			nextAngle3 = angle3 + start2;
			if(angle3 >= dA3 + angleInc3) {
				break;
			}
			p3.push({ x : dx + radiusSmall * Math.cos(nextAngle3), y : dy + radiusSmall * Math.sin(nextAngle3)});
		}
	}
	p3.reverse();
	var p0_ = { x : dx, y : dy - radius};
	var p1_ = { x : dx + wid, y : dy - radius};
	var draw = new justTriangles_Draw();
	draw.p0 = p1_;
	draw.p1 = p0_;
	draw.halfA = Math.PI / 2;
	draw._thick = dia;
	draw.beta = Math.PI / 2 - draw.halfA;
	draw.r = draw._thick / 2 * Math.cos(draw.beta);
	draw._theta = draw.theta(draw.p0,draw.p1);
	if(draw._theta > 0) {
		if(draw.halfA < 0) {
			draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
			draw.angle1 = draw._theta - draw.halfA;
		} else {
			draw.angle1 = draw._theta + draw.halfA - Math.PI;
			draw.angle2 = draw._theta + draw.halfA;
		}
	} else if(draw.halfA > 0) {
		draw.angle1 = draw._theta + draw.halfA - Math.PI;
		draw.angle2 = draw._theta + draw.halfA;
	} else {
		draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
		draw.angle1 = draw._theta - draw.halfA;
	}
	if(draw.p3old != null) {
		draw.p3old2 = draw.p3old;
	}
	if(draw.p4old != null) {
		draw.p4old2 = draw.p4old;
	}
	if(draw.p3 != null) {
		draw.p3old = draw.p3;
	}
	if(draw.p4 != null) {
		draw.p4old = draw.p4;
	}
	draw.p3 = { x : draw.p1.x + draw.r * Math.cos(draw.angle1), y : draw.p1.y + draw.r * Math.sin(draw.angle1)};
	draw.p4 = { x : draw.p1.x + draw.r * Math.cos(draw.angle2), y : draw.p1.y + draw.r * Math.sin(draw.angle2)};
	var q0 = { x : draw.p3.x, y : draw.p3.y};
	var q1 = { x : draw.p4.x, y : draw.p4.y};
	draw.p0 = p0_;
	draw.p1 = p1_;
	draw._theta = draw.theta(draw.p0,draw.p1);
	if(draw._theta > 0) {
		if(draw.halfA < 0) {
			draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
			draw.angle1 = draw._theta - draw.halfA;
		} else {
			draw.angle1 = draw._theta + draw.halfA - Math.PI;
			draw.angle2 = draw._theta + draw.halfA;
		}
	} else if(draw.halfA > 0) {
		draw.angle1 = draw._theta + draw.halfA - Math.PI;
		draw.angle2 = draw._theta + draw.halfA;
	} else {
		draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
		draw.angle1 = draw._theta - draw.halfA;
	}
	if(draw.p3old != null) {
		draw.p3old2 = draw.p3old;
	}
	if(draw.p4old != null) {
		draw.p4old2 = draw.p4old;
	}
	if(draw.p3 != null) {
		draw.p3old = draw.p3;
	}
	if(draw.p4 != null) {
		draw.p4old = draw.p4;
	}
	draw.p3 = { x : draw.p1.x + draw.r * Math.cos(draw.angle1), y : draw.p1.y + draw.r * Math.sin(draw.angle1)};
	draw.p4 = { x : draw.p1.x + draw.r * Math.cos(draw.angle2), y : draw.p1.y + draw.r * Math.sin(draw.angle2)};
	var q3 = { x : draw.p3.x, y : draw.p3.y};
	var q4 = { x : draw.p4.x, y : draw.p4.y};
	justTriangles_Draw.drawTri(id,true,q0,q3,q1,justTriangles_Draw.colorId);
	justTriangles_Draw.drawTri(id,true,q0,q3,q4,justTriangles_Draw.colorId);
	var p0_1 = { x : dx + radius + wid, y : dy};
	var p1_1 = { x : dx + radius + wid, y : dy + hi};
	var draw1 = new justTriangles_Draw();
	draw1.p0 = p1_1;
	draw1.p1 = p0_1;
	draw1.halfA = Math.PI / 2;
	draw1._thick = dia;
	draw1.beta = Math.PI / 2 - draw1.halfA;
	draw1.r = draw1._thick / 2 * Math.cos(draw1.beta);
	draw1._theta = draw1.theta(draw1.p0,draw1.p1);
	if(draw1._theta > 0) {
		if(draw1.halfA < 0) {
			draw1.angle2 = draw1._theta + draw1.halfA + Math.PI / 2;
			draw1.angle1 = draw1._theta - draw1.halfA;
		} else {
			draw1.angle1 = draw1._theta + draw1.halfA - Math.PI;
			draw1.angle2 = draw1._theta + draw1.halfA;
		}
	} else if(draw1.halfA > 0) {
		draw1.angle1 = draw1._theta + draw1.halfA - Math.PI;
		draw1.angle2 = draw1._theta + draw1.halfA;
	} else {
		draw1.angle2 = draw1._theta + draw1.halfA + Math.PI / 2;
		draw1.angle1 = draw1._theta - draw1.halfA;
	}
	if(draw1.p3old != null) {
		draw1.p3old2 = draw1.p3old;
	}
	if(draw1.p4old != null) {
		draw1.p4old2 = draw1.p4old;
	}
	if(draw1.p3 != null) {
		draw1.p3old = draw1.p3;
	}
	if(draw1.p4 != null) {
		draw1.p4old = draw1.p4;
	}
	draw1.p3 = { x : draw1.p1.x + draw1.r * Math.cos(draw1.angle1), y : draw1.p1.y + draw1.r * Math.sin(draw1.angle1)};
	draw1.p4 = { x : draw1.p1.x + draw1.r * Math.cos(draw1.angle2), y : draw1.p1.y + draw1.r * Math.sin(draw1.angle2)};
	var q01 = { x : draw1.p3.x, y : draw1.p3.y};
	var q11 = { x : draw1.p4.x, y : draw1.p4.y};
	draw1.p0 = p0_1;
	draw1.p1 = p1_1;
	draw1._theta = draw1.theta(draw1.p0,draw1.p1);
	if(draw1._theta > 0) {
		if(draw1.halfA < 0) {
			draw1.angle2 = draw1._theta + draw1.halfA + Math.PI / 2;
			draw1.angle1 = draw1._theta - draw1.halfA;
		} else {
			draw1.angle1 = draw1._theta + draw1.halfA - Math.PI;
			draw1.angle2 = draw1._theta + draw1.halfA;
		}
	} else if(draw1.halfA > 0) {
		draw1.angle1 = draw1._theta + draw1.halfA - Math.PI;
		draw1.angle2 = draw1._theta + draw1.halfA;
	} else {
		draw1.angle2 = draw1._theta + draw1.halfA + Math.PI / 2;
		draw1.angle1 = draw1._theta - draw1.halfA;
	}
	if(draw1.p3old != null) {
		draw1.p3old2 = draw1.p3old;
	}
	if(draw1.p4old != null) {
		draw1.p4old2 = draw1.p4old;
	}
	if(draw1.p3 != null) {
		draw1.p3old = draw1.p3;
	}
	if(draw1.p4 != null) {
		draw1.p4old = draw1.p4;
	}
	draw1.p3 = { x : draw1.p1.x + draw1.r * Math.cos(draw1.angle1), y : draw1.p1.y + draw1.r * Math.sin(draw1.angle1)};
	draw1.p4 = { x : draw1.p1.x + draw1.r * Math.cos(draw1.angle2), y : draw1.p1.y + draw1.r * Math.sin(draw1.angle2)};
	var q31 = { x : draw1.p3.x, y : draw1.p3.y};
	var q41 = { x : draw1.p4.x, y : draw1.p4.y};
	justTriangles_Draw.drawTri(id,true,q01,q31,q11,justTriangles_Draw.colorId);
	justTriangles_Draw.drawTri(id,true,q01,q31,q41,justTriangles_Draw.colorId);
	var p0_2 = { x : dx, y : dy + radius + hi};
	var p1_2 = { x : dx + wid, y : dy + radius + hi};
	var draw2 = new justTriangles_Draw();
	draw2.p0 = p1_2;
	draw2.p1 = p0_2;
	draw2.halfA = Math.PI / 2;
	draw2._thick = dia;
	draw2.beta = Math.PI / 2 - draw2.halfA;
	draw2.r = draw2._thick / 2 * Math.cos(draw2.beta);
	draw2._theta = draw2.theta(draw2.p0,draw2.p1);
	if(draw2._theta > 0) {
		if(draw2.halfA < 0) {
			draw2.angle2 = draw2._theta + draw2.halfA + Math.PI / 2;
			draw2.angle1 = draw2._theta - draw2.halfA;
		} else {
			draw2.angle1 = draw2._theta + draw2.halfA - Math.PI;
			draw2.angle2 = draw2._theta + draw2.halfA;
		}
	} else if(draw2.halfA > 0) {
		draw2.angle1 = draw2._theta + draw2.halfA - Math.PI;
		draw2.angle2 = draw2._theta + draw2.halfA;
	} else {
		draw2.angle2 = draw2._theta + draw2.halfA + Math.PI / 2;
		draw2.angle1 = draw2._theta - draw2.halfA;
	}
	if(draw2.p3old != null) {
		draw2.p3old2 = draw2.p3old;
	}
	if(draw2.p4old != null) {
		draw2.p4old2 = draw2.p4old;
	}
	if(draw2.p3 != null) {
		draw2.p3old = draw2.p3;
	}
	if(draw2.p4 != null) {
		draw2.p4old = draw2.p4;
	}
	draw2.p3 = { x : draw2.p1.x + draw2.r * Math.cos(draw2.angle1), y : draw2.p1.y + draw2.r * Math.sin(draw2.angle1)};
	draw2.p4 = { x : draw2.p1.x + draw2.r * Math.cos(draw2.angle2), y : draw2.p1.y + draw2.r * Math.sin(draw2.angle2)};
	var q02 = { x : draw2.p3.x, y : draw2.p3.y};
	var q12 = { x : draw2.p4.x, y : draw2.p4.y};
	draw2.p0 = p0_2;
	draw2.p1 = p1_2;
	draw2._theta = draw2.theta(draw2.p0,draw2.p1);
	if(draw2._theta > 0) {
		if(draw2.halfA < 0) {
			draw2.angle2 = draw2._theta + draw2.halfA + Math.PI / 2;
			draw2.angle1 = draw2._theta - draw2.halfA;
		} else {
			draw2.angle1 = draw2._theta + draw2.halfA - Math.PI;
			draw2.angle2 = draw2._theta + draw2.halfA;
		}
	} else if(draw2.halfA > 0) {
		draw2.angle1 = draw2._theta + draw2.halfA - Math.PI;
		draw2.angle2 = draw2._theta + draw2.halfA;
	} else {
		draw2.angle2 = draw2._theta + draw2.halfA + Math.PI / 2;
		draw2.angle1 = draw2._theta - draw2.halfA;
	}
	if(draw2.p3old != null) {
		draw2.p3old2 = draw2.p3old;
	}
	if(draw2.p4old != null) {
		draw2.p4old2 = draw2.p4old;
	}
	if(draw2.p3 != null) {
		draw2.p3old = draw2.p3;
	}
	if(draw2.p4 != null) {
		draw2.p4old = draw2.p4;
	}
	draw2.p3 = { x : draw2.p1.x + draw2.r * Math.cos(draw2.angle1), y : draw2.p1.y + draw2.r * Math.sin(draw2.angle1)};
	draw2.p4 = { x : draw2.p1.x + draw2.r * Math.cos(draw2.angle2), y : draw2.p1.y + draw2.r * Math.sin(draw2.angle2)};
	var q32 = { x : draw2.p3.x, y : draw2.p3.y};
	var q42 = { x : draw2.p4.x, y : draw2.p4.y};
	justTriangles_Draw.drawTri(id,true,q02,q32,q12,justTriangles_Draw.colorId);
	justTriangles_Draw.drawTri(id,true,q02,q32,q42,justTriangles_Draw.colorId);
	var p0_3 = { x : dx - radius, y : dy};
	var p1_3 = { x : dx - radius, y : dy + hi};
	var draw3 = new justTriangles_Draw();
	draw3.p0 = p1_3;
	draw3.p1 = p0_3;
	draw3.halfA = Math.PI / 2;
	draw3._thick = dia;
	draw3.beta = Math.PI / 2 - draw3.halfA;
	draw3.r = draw3._thick / 2 * Math.cos(draw3.beta);
	draw3._theta = draw3.theta(draw3.p0,draw3.p1);
	if(draw3._theta > 0) {
		if(draw3.halfA < 0) {
			draw3.angle2 = draw3._theta + draw3.halfA + Math.PI / 2;
			draw3.angle1 = draw3._theta - draw3.halfA;
		} else {
			draw3.angle1 = draw3._theta + draw3.halfA - Math.PI;
			draw3.angle2 = draw3._theta + draw3.halfA;
		}
	} else if(draw3.halfA > 0) {
		draw3.angle1 = draw3._theta + draw3.halfA - Math.PI;
		draw3.angle2 = draw3._theta + draw3.halfA;
	} else {
		draw3.angle2 = draw3._theta + draw3.halfA + Math.PI / 2;
		draw3.angle1 = draw3._theta - draw3.halfA;
	}
	if(draw3.p3old != null) {
		draw3.p3old2 = draw3.p3old;
	}
	if(draw3.p4old != null) {
		draw3.p4old2 = draw3.p4old;
	}
	if(draw3.p3 != null) {
		draw3.p3old = draw3.p3;
	}
	if(draw3.p4 != null) {
		draw3.p4old = draw3.p4;
	}
	draw3.p3 = { x : draw3.p1.x + draw3.r * Math.cos(draw3.angle1), y : draw3.p1.y + draw3.r * Math.sin(draw3.angle1)};
	draw3.p4 = { x : draw3.p1.x + draw3.r * Math.cos(draw3.angle2), y : draw3.p1.y + draw3.r * Math.sin(draw3.angle2)};
	var q03 = { x : draw3.p3.x, y : draw3.p3.y};
	var q13 = { x : draw3.p4.x, y : draw3.p4.y};
	draw3.p0 = p0_3;
	draw3.p1 = p1_3;
	draw3._theta = draw3.theta(draw3.p0,draw3.p1);
	if(draw3._theta > 0) {
		if(draw3.halfA < 0) {
			draw3.angle2 = draw3._theta + draw3.halfA + Math.PI / 2;
			draw3.angle1 = draw3._theta - draw3.halfA;
		} else {
			draw3.angle1 = draw3._theta + draw3.halfA - Math.PI;
			draw3.angle2 = draw3._theta + draw3.halfA;
		}
	} else if(draw3.halfA > 0) {
		draw3.angle1 = draw3._theta + draw3.halfA - Math.PI;
		draw3.angle2 = draw3._theta + draw3.halfA;
	} else {
		draw3.angle2 = draw3._theta + draw3.halfA + Math.PI / 2;
		draw3.angle1 = draw3._theta - draw3.halfA;
	}
	if(draw3.p3old != null) {
		draw3.p3old2 = draw3.p3old;
	}
	if(draw3.p4old != null) {
		draw3.p4old2 = draw3.p4old;
	}
	if(draw3.p3 != null) {
		draw3.p3old = draw3.p3;
	}
	if(draw3.p4 != null) {
		draw3.p4old = draw3.p4;
	}
	draw3.p3 = { x : draw3.p1.x + draw3.r * Math.cos(draw3.angle1), y : draw3.p1.y + draw3.r * Math.sin(draw3.angle1)};
	draw3.p4 = { x : draw3.p1.x + draw3.r * Math.cos(draw3.angle2), y : draw3.p1.y + draw3.r * Math.sin(draw3.angle2)};
	var q33 = { x : draw3.p3.x, y : draw3.p3.y};
	var q43 = { x : draw3.p4.x, y : draw3.p4.y};
	justTriangles_Draw.drawTri(id,true,q03,q33,q13,justTriangles_Draw.colorId);
	justTriangles_Draw.drawTri(id,true,q03,q33,q43,justTriangles_Draw.colorId);
	var centre = { x : dx, y : dy + hi};
	justTriangles_Draw.q0 = p[0];
	justTriangles_Draw.q1 = p[0];
	var draw4 = new justTriangles_Draw();
	draw4.create2Lines(p[0],p[1],p[2],justTriangles_Draw.thickness);
	justTriangles_Draw.q0 = draw4.p3;
	justTriangles_Draw.q1 = draw4.p4;
	var _g1 = 1;
	var _g = p.length - 2;
	while(_g1 < _g) {
		draw4.rebuildAsPoly(p[_g1++ + 2]);
		var q34 = draw4.p3;
		justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q0,q34,centre,justTriangles_Draw.colorId);
		justTriangles_Draw.q0 = q34;
	}
	var centre1 = { x : dx + wid, y : dy + hi};
	justTriangles_Draw.q0 = p1[0];
	justTriangles_Draw.q1 = p1[0];
	var draw5 = new justTriangles_Draw();
	draw5.create2Lines(p1[0],p1[1],p1[2],justTriangles_Draw.thickness);
	justTriangles_Draw.q0 = draw5.p3;
	justTriangles_Draw.q1 = draw5.p4;
	var _g11 = 1;
	var _g2 = p1.length - 2;
	while(_g11 < _g2) {
		draw5.rebuildAsPoly(p1[_g11++ + 2]);
		var q35 = draw5.p3;
		justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q0,q35,centre1,justTriangles_Draw.colorId);
		justTriangles_Draw.q0 = q35;
	}
	var centre2 = { x : dx + wid, y : dy};
	justTriangles_Draw.q0 = p2[0];
	justTriangles_Draw.q1 = p2[0];
	var draw6 = new justTriangles_Draw();
	draw6.create2Lines(p2[0],p2[1],p2[2],justTriangles_Draw.thickness);
	justTriangles_Draw.q0 = draw6.p3;
	justTriangles_Draw.q1 = draw6.p4;
	var _g12 = 1;
	var _g3 = p2.length - 2;
	while(_g12 < _g3) {
		draw6.rebuildAsPoly(p2[_g12++ + 2]);
		var q36 = draw6.p3;
		justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q0,q36,centre2,justTriangles_Draw.colorId);
		justTriangles_Draw.q0 = q36;
	}
	var centre3 = { x : dx, y : dy};
	justTriangles_Draw.q0 = p3[0];
	justTriangles_Draw.q1 = p3[0];
	var draw7 = new justTriangles_Draw();
	draw7.create2Lines(p3[0],p3[1],p3[2],justTriangles_Draw.thickness);
	justTriangles_Draw.q0 = draw7.p3;
	justTriangles_Draw.q1 = draw7.p4;
	var _g13 = 1;
	var _g4 = p3.length - 2;
	while(_g13 < _g4) {
		draw7.rebuildAsPoly(p3[_g13++ + 2]);
		var q37 = draw7.p3;
		justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q0,q37,centre3,justTriangles_Draw.colorId);
		justTriangles_Draw.q0 = q37;
	}
};
justTriangles_Draw.beginLine = function(id,p0_,p1_,thick) {
	var draw = new justTriangles_Draw();
	draw.p0 = p1_;
	draw.p1 = p0_;
	draw.halfA = Math.PI / 2;
	draw._thick = thick;
	draw.beta = Math.PI / 2 - draw.halfA;
	draw.r = draw._thick / 2 * Math.cos(draw.beta);
	draw._theta = draw.theta(draw.p0,draw.p1);
	if(draw._theta > 0) {
		if(draw.halfA < 0) {
			draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
			draw.angle1 = draw._theta - draw.halfA;
		} else {
			draw.angle1 = draw._theta + draw.halfA - Math.PI;
			draw.angle2 = draw._theta + draw.halfA;
		}
	} else if(draw.halfA > 0) {
		draw.angle1 = draw._theta + draw.halfA - Math.PI;
		draw.angle2 = draw._theta + draw.halfA;
	} else {
		draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
		draw.angle1 = draw._theta - draw.halfA;
	}
	if(draw.p3old != null) {
		draw.p3old2 = draw.p3old;
	}
	if(draw.p4old != null) {
		draw.p4old2 = draw.p4old;
	}
	if(draw.p3 != null) {
		draw.p3old = draw.p3;
	}
	if(draw.p4 != null) {
		draw.p4old = draw.p4;
	}
	draw.p3 = { x : draw.p1.x + draw.r * Math.cos(draw.angle1), y : draw.p1.y + draw.r * Math.sin(draw.angle1)};
	draw.p4 = { x : draw.p1.x + draw.r * Math.cos(draw.angle2), y : draw.p1.y + draw.r * Math.sin(draw.angle2)};
	var q0 = { x : draw.p3.x, y : draw.p3.y};
	var q1 = { x : draw.p4.x, y : draw.p4.y};
	draw.p0 = p0_;
	draw.p1 = p1_;
	draw._theta = draw.theta(draw.p0,draw.p1);
	if(draw._theta > 0) {
		if(draw.halfA < 0) {
			draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
			draw.angle1 = draw._theta - draw.halfA;
		} else {
			draw.angle1 = draw._theta + draw.halfA - Math.PI;
			draw.angle2 = draw._theta + draw.halfA;
		}
	} else if(draw.halfA > 0) {
		draw.angle1 = draw._theta + draw.halfA - Math.PI;
		draw.angle2 = draw._theta + draw.halfA;
	} else {
		draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
		draw.angle1 = draw._theta - draw.halfA;
	}
	if(draw.p3old != null) {
		draw.p3old2 = draw.p3old;
	}
	if(draw.p4old != null) {
		draw.p4old2 = draw.p4old;
	}
	if(draw.p3 != null) {
		draw.p3old = draw.p3;
	}
	if(draw.p4 != null) {
		draw.p4old = draw.p4;
	}
	draw.p3 = { x : draw.p1.x + draw.r * Math.cos(draw.angle1), y : draw.p1.y + draw.r * Math.sin(draw.angle1)};
	draw.p4 = { x : draw.p1.x + draw.r * Math.cos(draw.angle2), y : draw.p1.y + draw.r * Math.sin(draw.angle2)};
	var oldThickness = justTriangles_Draw.thickness;
	justTriangles_Draw.thickness = thick / 2;
	var temp = draw.angle1;
	var dx = p0_.x;
	var dy = p0_.y;
	var radius = thick / 4;
	var dA = Math.PI;
	var p = [];
	var angle = 0;
	var angleInc = Math.PI * 2 / 24;
	var nextAngle;
	if(dA < 0) {
		var i = -1;
		while(true) {
			angle = i * angleInc;
			--i;
			nextAngle = angle + temp;
			if(angle <= dA) {
				break;
			}
			p.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
		}
	} else {
		var i1 = -1;
		while(true) {
			angle = i1 * angleInc;
			++i1;
			nextAngle = angle + temp;
			if(angle >= dA + angleInc) {
				break;
			}
			p.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
		}
	}
	p.reverse();
	justTriangles_Draw.q0 = p[0];
	justTriangles_Draw.q1 = p[0];
	var draw1 = new justTriangles_Draw();
	draw1.create2Lines(p[0],p[1],p[2],justTriangles_Draw.thickness);
	justTriangles_Draw.q0 = draw1.p3;
	justTriangles_Draw.q1 = draw1.p4;
	var _g1 = 1;
	var _g = p.length - 2;
	while(_g1 < _g) {
		draw1.rebuildAsPoly(p[_g1++ + 2]);
		var q3 = draw1.p3;
		justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q0,q3,p0_,justTriangles_Draw.colorId);
		justTriangles_Draw.q0 = q3;
	}
	justTriangles_Draw.thickness = oldThickness;
	var q31 = { x : draw.p3.x, y : draw.p3.y};
	var q4 = { x : draw.p4.x, y : draw.p4.y};
	justTriangles_Draw.drawTri(id,true,q0,q31,q1,justTriangles_Draw.colorId);
	justTriangles_Draw.drawTri(id,true,q0,q31,q4,justTriangles_Draw.colorId);
	return draw;
};
justTriangles_Draw.endLine = function(id,p0_,p1_,thick) {
	var draw = new justTriangles_Draw();
	draw.p0 = p1_;
	draw.p1 = p0_;
	draw.halfA = Math.PI / 2;
	draw._thick = thick;
	draw.beta = Math.PI / 2 - draw.halfA;
	draw.r = draw._thick / 2 * Math.cos(draw.beta);
	draw._theta = draw.theta(draw.p0,draw.p1);
	if(draw._theta > 0) {
		if(draw.halfA < 0) {
			draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
			draw.angle1 = draw._theta - draw.halfA;
		} else {
			draw.angle1 = draw._theta + draw.halfA - Math.PI;
			draw.angle2 = draw._theta + draw.halfA;
		}
	} else if(draw.halfA > 0) {
		draw.angle1 = draw._theta + draw.halfA - Math.PI;
		draw.angle2 = draw._theta + draw.halfA;
	} else {
		draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
		draw.angle1 = draw._theta - draw.halfA;
	}
	if(draw.p3old != null) {
		draw.p3old2 = draw.p3old;
	}
	if(draw.p4old != null) {
		draw.p4old2 = draw.p4old;
	}
	if(draw.p3 != null) {
		draw.p3old = draw.p3;
	}
	if(draw.p4 != null) {
		draw.p4old = draw.p4;
	}
	draw.p3 = { x : draw.p1.x + draw.r * Math.cos(draw.angle1), y : draw.p1.y + draw.r * Math.sin(draw.angle1)};
	draw.p4 = { x : draw.p1.x + draw.r * Math.cos(draw.angle2), y : draw.p1.y + draw.r * Math.sin(draw.angle2)};
	var q0 = { x : draw.p3.x, y : draw.p3.y};
	var q1 = { x : draw.p4.x, y : draw.p4.y};
	draw.p0 = p0_;
	draw.p1 = p1_;
	draw._theta = draw.theta(draw.p0,draw.p1);
	if(draw._theta > 0) {
		if(draw.halfA < 0) {
			draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
			draw.angle1 = draw._theta - draw.halfA;
		} else {
			draw.angle1 = draw._theta + draw.halfA - Math.PI;
			draw.angle2 = draw._theta + draw.halfA;
		}
	} else if(draw.halfA > 0) {
		draw.angle1 = draw._theta + draw.halfA - Math.PI;
		draw.angle2 = draw._theta + draw.halfA;
	} else {
		draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
		draw.angle1 = draw._theta - draw.halfA;
	}
	if(draw.p3old != null) {
		draw.p3old2 = draw.p3old;
	}
	if(draw.p4old != null) {
		draw.p4old2 = draw.p4old;
	}
	if(draw.p3 != null) {
		draw.p3old = draw.p3;
	}
	if(draw.p4 != null) {
		draw.p4old = draw.p4;
	}
	draw.p3 = { x : draw.p1.x + draw.r * Math.cos(draw.angle1), y : draw.p1.y + draw.r * Math.sin(draw.angle1)};
	draw.p4 = { x : draw.p1.x + draw.r * Math.cos(draw.angle2), y : draw.p1.y + draw.r * Math.sin(draw.angle2)};
	var oldThickness = justTriangles_Draw.thickness;
	justTriangles_Draw.thickness = thick / 2;
	var temp = draw.angle1 + Math.PI;
	var dx = p1_.x;
	var dy = p1_.y;
	var radius = thick / 4;
	var dA = Math.PI;
	var p = [];
	var angle = 0;
	var angleInc = Math.PI * 2 / 24;
	var nextAngle;
	if(dA < 0) {
		var i = -1;
		while(true) {
			angle = i * angleInc;
			--i;
			nextAngle = angle + temp;
			if(angle <= dA) {
				break;
			}
			p.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
		}
	} else {
		var i1 = -1;
		while(true) {
			angle = i1 * angleInc;
			++i1;
			nextAngle = angle + temp;
			if(angle >= dA + angleInc) {
				break;
			}
			p.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
		}
	}
	p.reverse();
	justTriangles_Draw.q0 = p[0];
	justTriangles_Draw.q1 = p[0];
	var draw1 = new justTriangles_Draw();
	draw1.create2Lines(p[0],p[1],p[2],justTriangles_Draw.thickness);
	justTriangles_Draw.q0 = draw1.p3;
	justTriangles_Draw.q1 = draw1.p4;
	var _g1 = 1;
	var _g = p.length - 2;
	while(_g1 < _g) {
		draw1.rebuildAsPoly(p[_g1++ + 2]);
		var q3 = draw1.p3;
		justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q0,q3,p1_,justTriangles_Draw.colorId);
		justTriangles_Draw.q0 = q3;
	}
	justTriangles_Draw.thickness = oldThickness;
	var q31 = { x : draw.p3.x, y : draw.p3.y};
	var q4 = { x : draw.p4.x, y : draw.p4.y};
	justTriangles_Draw.drawTri(id,true,q0,q31,q1,justTriangles_Draw.colorId);
	justTriangles_Draw.drawTri(id,true,q0,q31,q4,justTriangles_Draw.colorId);
	return draw;
};
justTriangles_Draw.isolatedLine = function(id,p0_,p1_,thick,curveEnds) {
	if(curveEnds == null) {
		curveEnds = false;
	}
	var draw = new justTriangles_Draw();
	draw.p0 = p1_;
	draw.p1 = p0_;
	draw.halfA = Math.PI / 2;
	draw._thick = thick;
	draw.beta = Math.PI / 2 - draw.halfA;
	draw.r = draw._thick / 2 * Math.cos(draw.beta);
	draw._theta = draw.theta(draw.p0,draw.p1);
	if(draw._theta > 0) {
		if(draw.halfA < 0) {
			draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
			draw.angle1 = draw._theta - draw.halfA;
		} else {
			draw.angle1 = draw._theta + draw.halfA - Math.PI;
			draw.angle2 = draw._theta + draw.halfA;
		}
	} else if(draw.halfA > 0) {
		draw.angle1 = draw._theta + draw.halfA - Math.PI;
		draw.angle2 = draw._theta + draw.halfA;
	} else {
		draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
		draw.angle1 = draw._theta - draw.halfA;
	}
	if(draw.p3old != null) {
		draw.p3old2 = draw.p3old;
	}
	if(draw.p4old != null) {
		draw.p4old2 = draw.p4old;
	}
	if(draw.p3 != null) {
		draw.p3old = draw.p3;
	}
	if(draw.p4 != null) {
		draw.p4old = draw.p4;
	}
	draw.p3 = { x : draw.p1.x + draw.r * Math.cos(draw.angle1), y : draw.p1.y + draw.r * Math.sin(draw.angle1)};
	draw.p4 = { x : draw.p1.x + draw.r * Math.cos(draw.angle2), y : draw.p1.y + draw.r * Math.sin(draw.angle2)};
	var q0 = { x : draw.p3.x, y : draw.p3.y};
	var q1 = { x : draw.p4.x, y : draw.p4.y};
	draw.p0 = p0_;
	draw.p1 = p1_;
	draw._theta = draw.theta(draw.p0,draw.p1);
	if(draw._theta > 0) {
		if(draw.halfA < 0) {
			draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
			draw.angle1 = draw._theta - draw.halfA;
		} else {
			draw.angle1 = draw._theta + draw.halfA - Math.PI;
			draw.angle2 = draw._theta + draw.halfA;
		}
	} else if(draw.halfA > 0) {
		draw.angle1 = draw._theta + draw.halfA - Math.PI;
		draw.angle2 = draw._theta + draw.halfA;
	} else {
		draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
		draw.angle1 = draw._theta - draw.halfA;
	}
	if(draw.p3old != null) {
		draw.p3old2 = draw.p3old;
	}
	if(draw.p4old != null) {
		draw.p4old2 = draw.p4old;
	}
	if(draw.p3 != null) {
		draw.p3old = draw.p3;
	}
	if(draw.p4 != null) {
		draw.p4old = draw.p4;
	}
	draw.p3 = { x : draw.p1.x + draw.r * Math.cos(draw.angle1), y : draw.p1.y + draw.r * Math.sin(draw.angle1)};
	draw.p4 = { x : draw.p1.x + draw.r * Math.cos(draw.angle2), y : draw.p1.y + draw.r * Math.sin(draw.angle2)};
	if(curveEnds) {
		var oldThickness = justTriangles_Draw.thickness;
		justTriangles_Draw.thickness = thick / 2;
		var temp = draw.angle1;
		var dx = p0_.x;
		var dy = p0_.y;
		var radius = thick / 4;
		var dA = Math.PI;
		var p = [];
		var angle = 0;
		var angleInc = Math.PI * 2 / 24;
		var nextAngle;
		if(dA < 0) {
			var i = -1;
			while(true) {
				angle = i * angleInc;
				--i;
				nextAngle = angle + temp;
				if(angle <= dA) {
					break;
				}
				p.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
			}
		} else {
			var i1 = -1;
			while(true) {
				angle = i1 * angleInc;
				++i1;
				nextAngle = angle + temp;
				if(angle >= dA + angleInc) {
					break;
				}
				p.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
			}
		}
		p.reverse();
		justTriangles_Draw.q0 = p[0];
		justTriangles_Draw.q1 = p[0];
		var draw1 = new justTriangles_Draw();
		draw1.create2Lines(p[0],p[1],p[2],justTriangles_Draw.thickness);
		justTriangles_Draw.q0 = draw1.p3;
		justTriangles_Draw.q1 = draw1.p4;
		var _g1 = 1;
		var _g = p.length - 2;
		while(_g1 < _g) {
			draw1.rebuildAsPoly(p[_g1++ + 2]);
			var q3 = draw1.p3;
			justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q0,q3,p0_,justTriangles_Draw.colorId);
			justTriangles_Draw.q0 = q3;
		}
		temp += Math.PI;
		var dx1 = p1_.x;
		var dy1 = p1_.y;
		var radius1 = thick / 4;
		var dA1 = Math.PI;
		var p1 = [];
		var angle1 = 0;
		var angleInc1 = Math.PI * 2 / 24;
		var nextAngle1;
		if(dA1 < 0) {
			var i2 = -1;
			while(true) {
				angle1 = i2 * angleInc1;
				--i2;
				nextAngle1 = angle1 + temp;
				if(angle1 <= dA1) {
					break;
				}
				p1.push({ x : dx1 + radius1 * Math.cos(nextAngle1), y : dy1 + radius1 * Math.sin(nextAngle1)});
			}
		} else {
			var i3 = -1;
			while(true) {
				angle1 = i3 * angleInc1;
				++i3;
				nextAngle1 = angle1 + temp;
				if(angle1 >= dA1 + angleInc1) {
					break;
				}
				p1.push({ x : dx1 + radius1 * Math.cos(nextAngle1), y : dy1 + radius1 * Math.sin(nextAngle1)});
			}
		}
		p1.reverse();
		justTriangles_Draw.q0 = p1[0];
		justTriangles_Draw.q1 = p1[0];
		var draw2 = new justTriangles_Draw();
		draw2.create2Lines(p1[0],p1[1],p1[2],justTriangles_Draw.thickness);
		justTriangles_Draw.q0 = draw2.p3;
		justTriangles_Draw.q1 = draw2.p4;
		var _g11 = 1;
		var _g2 = p1.length - 2;
		while(_g11 < _g2) {
			draw2.rebuildAsPoly(p1[_g11++ + 2]);
			var q31 = draw2.p3;
			justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q0,q31,p1_,justTriangles_Draw.colorId);
			justTriangles_Draw.q0 = q31;
		}
		justTriangles_Draw.thickness = oldThickness;
	}
	var q32 = { x : draw.p3.x, y : draw.p3.y};
	var q4 = { x : draw.p4.x, y : draw.p4.y};
	justTriangles_Draw.drawTri(id,true,q0,q32,q1,justTriangles_Draw.colorId);
	justTriangles_Draw.drawTri(id,true,q0,q32,q4,justTriangles_Draw.colorId);
	return draw;
};
justTriangles_Draw.triangleJoin = function(id,draw,p0_,p1_,thick,curveEnds) {
	if(curveEnds == null) {
		curveEnds = false;
	}
	var oldAngle = draw.p3 != null ? draw.angle1 : null;
	draw.p0 = p1_;
	draw.p1 = p0_;
	draw.halfA = Math.PI / 2;
	draw._thick = thick;
	draw.beta = Math.PI / 2 - draw.halfA;
	draw.r = draw._thick / 2 * Math.cos(draw.beta);
	draw._theta = draw.theta(draw.p0,draw.p1);
	if(draw._theta > 0) {
		if(draw.halfA < 0) {
			draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
			draw.angle1 = draw._theta - draw.halfA;
		} else {
			draw.angle1 = draw._theta + draw.halfA - Math.PI;
			draw.angle2 = draw._theta + draw.halfA;
		}
	} else if(draw.halfA > 0) {
		draw.angle1 = draw._theta + draw.halfA - Math.PI;
		draw.angle2 = draw._theta + draw.halfA;
	} else {
		draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
		draw.angle1 = draw._theta - draw.halfA;
	}
	if(draw.p3old != null) {
		draw.p3old2 = draw.p3old;
	}
	if(draw.p4old != null) {
		draw.p4old2 = draw.p4old;
	}
	if(draw.p3 != null) {
		draw.p3old = draw.p3;
	}
	if(draw.p4 != null) {
		draw.p4old = draw.p4;
	}
	draw.p3 = { x : draw.p1.x + draw.r * Math.cos(draw.angle1), y : draw.p1.y + draw.r * Math.sin(draw.angle1)};
	draw.p4 = { x : draw.p1.x + draw.r * Math.cos(draw.angle2), y : draw.p1.y + draw.r * Math.sin(draw.angle2)};
	var q0 = { x : draw.p3.x, y : draw.p3.y};
	var q1 = { x : draw.p4.x, y : draw.p4.y};
	draw.p0 = p0_;
	draw.p1 = p1_;
	draw._theta = draw.theta(draw.p0,draw.p1);
	if(draw._theta > 0) {
		if(draw.halfA < 0) {
			draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
			draw.angle1 = draw._theta - draw.halfA;
		} else {
			draw.angle1 = draw._theta + draw.halfA - Math.PI;
			draw.angle2 = draw._theta + draw.halfA;
		}
	} else if(draw.halfA > 0) {
		draw.angle1 = draw._theta + draw.halfA - Math.PI;
		draw.angle2 = draw._theta + draw.halfA;
	} else {
		draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
		draw.angle1 = draw._theta - draw.halfA;
	}
	if(draw.p3old != null) {
		draw.p3old2 = draw.p3old;
	}
	if(draw.p4old != null) {
		draw.p4old2 = draw.p4old;
	}
	if(draw.p3 != null) {
		draw.p3old = draw.p3;
	}
	if(draw.p4 != null) {
		draw.p4old = draw.p4;
	}
	draw.p3 = { x : draw.p1.x + draw.r * Math.cos(draw.angle1), y : draw.p1.y + draw.r * Math.sin(draw.angle1)};
	draw.p4 = { x : draw.p1.x + draw.r * Math.cos(draw.angle2), y : draw.p1.y + draw.r * Math.sin(draw.angle2)};
	if(draw.p3old2 != null) {
		var clockWise = justTriangles_Draw.dist(draw.p3old2,p1_) > justTriangles_Draw.dist(draw.p4old2,p1_);
		if(curveEnds) {
			if(oldAngle != null) {
				var dif = Math.abs(draw.angle1 - oldAngle);
				if(dif > 0.1) {
					var oldThickness = justTriangles_Draw.thickness;
					justTriangles_Draw.thickness = thick / 2;
					if(clockWise) {
						var dx = p0_.x;
						var dy = p0_.y;
						var radius = thick / 4;
						var start = draw.angle1;
						var p = [];
						var angle = 0;
						var angleInc = Math.PI * 2 / 240;
						var nextAngle;
						if(dif < 0) {
							var i = -1;
							while(true) {
								angle = i * angleInc;
								--i;
								nextAngle = angle + start;
								if(angle <= dif) {
									break;
								}
								p.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
							}
						} else {
							var i1 = -1;
							while(true) {
								angle = i1 * angleInc;
								++i1;
								nextAngle = angle + start;
								if(angle >= dif + angleInc) {
									break;
								}
								p.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
							}
							p.reverse();
						}
						justTriangles_Draw.q0 = p[0];
						justTriangles_Draw.q1 = p[0];
						var draw1 = new justTriangles_Draw();
						draw1.create2Lines(p[0],p[1],p[2],justTriangles_Draw.thickness);
						justTriangles_Draw.q0 = draw1.p3;
						justTriangles_Draw.q1 = draw1.p4;
						var _g1 = 1;
						var _g = p.length - 2;
						while(_g1 < _g) {
							draw1.rebuildAsPoly(p[_g1++ + 2]);
							var q3 = draw1.p3;
							justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q0,q3,p0_,justTriangles_Draw.colorId);
							justTriangles_Draw.q0 = q3;
						}
					} else {
						var dx1 = p0_.x;
						var dy1 = p0_.y;
						var radius1 = thick / 4;
						var start1 = draw.angle2;
						var dA = -dif;
						var p1 = [];
						var angle1 = 0;
						var angleInc1 = Math.PI * 2 / 240;
						var nextAngle1;
						if(dA < 0) {
							var i2 = -1;
							while(true) {
								angle1 = i2 * angleInc1;
								--i2;
								nextAngle1 = angle1 + start1;
								if(angle1 <= dA) {
									break;
								}
								p1.push({ x : dx1 + radius1 * Math.cos(nextAngle1), y : dy1 + radius1 * Math.sin(nextAngle1)});
							}
						} else {
							var i3 = -1;
							while(true) {
								angle1 = i3 * angleInc1;
								++i3;
								nextAngle1 = angle1 + start1;
								if(angle1 >= dA + angleInc1) {
									break;
								}
								p1.push({ x : dx1 + radius1 * Math.cos(nextAngle1), y : dy1 + radius1 * Math.sin(nextAngle1)});
							}
							p1.reverse();
						}
						justTriangles_Draw.q0 = p1[0];
						justTriangles_Draw.q1 = p1[0];
						var draw2 = new justTriangles_Draw();
						draw2.create2Lines(p1[0],p1[1],p1[2],justTriangles_Draw.thickness);
						justTriangles_Draw.q0 = draw2.p3;
						justTriangles_Draw.q1 = draw2.p4;
						var _g11 = 1;
						var _g2 = p1.length - 2;
						while(_g11 < _g2) {
							draw2.rebuildAsPoly(p1[_g11++ + 2]);
							var q31 = draw2.p3;
							justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q0,q31,p0_,justTriangles_Draw.colorId);
							justTriangles_Draw.q0 = q31;
						}
					}
					justTriangles_Draw.thickness = oldThickness;
				}
			}
		}
		if(clockWise) {
			justTriangles_Draw.drawTri(id,true,draw.p3old2,q1,p0_,justTriangles_Draw.colorId);
		} else {
			justTriangles_Draw.drawTri(id,true,draw.p4old2,q0,p0_,justTriangles_Draw.colorId);
		}
	}
	justTriangles_Draw.drawTri(id,true,draw.p3old,draw.p3,draw.p4old,justTriangles_Draw.colorId);
	justTriangles_Draw.drawTri(id,true,draw.p3old,draw.p3,draw.p4,justTriangles_Draw.colorId);
	return draw;
};
justTriangles_Draw.quadCurves = function(id,p,thick) {
	var curveLen;
	var len = p.length - 1;
	var _g1 = 0;
	while(_g1 < len) {
		var i = _g1++;
		if((i - 1) % 2 == 0) {
			var p0 = p[i];
			var p1 = p[i + 1];
			var p2 = p[i + 2];
			var p3 = [];
			var x = p0.x - p1.x;
			var y = p0.y - p1.y;
			var x1 = p1.x - p2.x;
			var y1 = p1.y - p2.y;
			var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
			var v;
			if(approxDistance == 0) {
				approxDistance = 0.000001;
			}
			var step = Math.min(1 / (approxDistance * 0.707),justTriangles_ShapePoints.quadStep);
			var t = 0.0;
			p3.push(p0);
			t = step;
			while(t < 1) {
				var u = 1 - t;
				var u1 = 1 - t;
				v = { x : Math.pow(u,2) * p0.x + 2 * u * t * p1.x + Math.pow(t,2) * p2.x, y : Math.pow(u1,2) * p0.y + 2 * u1 * t * p1.y + Math.pow(t,2) * p2.y};
				p3.push({ x : v.x, y : v.y});
				t += step;
			}
			p3.push(p2);
			curveLen = p3.length;
			var p0_ = p3[0];
			var p1_ = p3[1];
			var draw = new justTriangles_Draw();
			draw.p0 = p1_;
			draw.p1 = p0_;
			draw.halfA = Math.PI / 2;
			draw._thick = thick;
			draw.beta = Math.PI / 2 - draw.halfA;
			draw.r = draw._thick / 2 * Math.cos(draw.beta);
			draw._theta = draw.theta(draw.p0,draw.p1);
			if(draw._theta > 0) {
				if(draw.halfA < 0) {
					draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
					draw.angle1 = draw._theta - draw.halfA;
				} else {
					draw.angle1 = draw._theta + draw.halfA - Math.PI;
					draw.angle2 = draw._theta + draw.halfA;
				}
			} else if(draw.halfA > 0) {
				draw.angle1 = draw._theta + draw.halfA - Math.PI;
				draw.angle2 = draw._theta + draw.halfA;
			} else {
				draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
				draw.angle1 = draw._theta - draw.halfA;
			}
			if(draw.p3old != null) {
				draw.p3old2 = draw.p3old;
			}
			if(draw.p4old != null) {
				draw.p4old2 = draw.p4old;
			}
			if(draw.p3 != null) {
				draw.p3old = draw.p3;
			}
			if(draw.p4 != null) {
				draw.p4old = draw.p4;
			}
			draw.p3 = { x : draw.p1.x + draw.r * Math.cos(draw.angle1), y : draw.p1.y + draw.r * Math.sin(draw.angle1)};
			draw.p4 = { x : draw.p1.x + draw.r * Math.cos(draw.angle2), y : draw.p1.y + draw.r * Math.sin(draw.angle2)};
			var q0 = { x : draw.p3.x, y : draw.p3.y};
			var q1 = { x : draw.p4.x, y : draw.p4.y};
			draw.p0 = p0_;
			draw.p1 = p1_;
			draw._theta = draw.theta(draw.p0,draw.p1);
			if(draw._theta > 0) {
				if(draw.halfA < 0) {
					draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
					draw.angle1 = draw._theta - draw.halfA;
				} else {
					draw.angle1 = draw._theta + draw.halfA - Math.PI;
					draw.angle2 = draw._theta + draw.halfA;
				}
			} else if(draw.halfA > 0) {
				draw.angle1 = draw._theta + draw.halfA - Math.PI;
				draw.angle2 = draw._theta + draw.halfA;
			} else {
				draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
				draw.angle1 = draw._theta - draw.halfA;
			}
			if(draw.p3old != null) {
				draw.p3old2 = draw.p3old;
			}
			if(draw.p4old != null) {
				draw.p4old2 = draw.p4old;
			}
			if(draw.p3 != null) {
				draw.p3old = draw.p3;
			}
			if(draw.p4 != null) {
				draw.p4old = draw.p4;
			}
			draw.p3 = { x : draw.p1.x + draw.r * Math.cos(draw.angle1), y : draw.p1.y + draw.r * Math.sin(draw.angle1)};
			draw.p4 = { x : draw.p1.x + draw.r * Math.cos(draw.angle2), y : draw.p1.y + draw.r * Math.sin(draw.angle2)};
			var oldThickness = justTriangles_Draw.thickness;
			justTriangles_Draw.thickness = thick / 2;
			var temp = draw.angle1;
			var dx = p0_.x;
			var dy = p0_.y;
			var radius = thick / 4;
			var dA = Math.PI;
			var p4 = [];
			var angle = 0;
			var angleInc = Math.PI * 2 / 24;
			var nextAngle;
			if(dA < 0) {
				var i1 = -1;
				while(true) {
					angle = i1 * angleInc;
					--i1;
					nextAngle = angle + temp;
					if(angle <= dA) {
						break;
					}
					p4.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
				}
			} else {
				var i2 = -1;
				while(true) {
					angle = i2 * angleInc;
					++i2;
					nextAngle = angle + temp;
					if(angle >= dA + angleInc) {
						break;
					}
					p4.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
				}
			}
			p4.reverse();
			justTriangles_Draw.q0 = p4[0];
			justTriangles_Draw.q1 = p4[0];
			var draw1 = new justTriangles_Draw();
			draw1.create2Lines(p4[0],p4[1],p4[2],justTriangles_Draw.thickness);
			justTriangles_Draw.q0 = draw1.p3;
			justTriangles_Draw.q1 = draw1.p4;
			var _g11 = 1;
			var _g = p4.length - 2;
			while(_g11 < _g) {
				draw1.rebuildAsPoly(p4[_g11++ + 2]);
				var q3 = draw1.p3;
				justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q0,q3,p0_,justTriangles_Draw.colorId);
				justTriangles_Draw.q0 = q3;
			}
			justTriangles_Draw.thickness = oldThickness;
			var q31 = { x : draw.p3.x, y : draw.p3.y};
			var q4 = { x : draw.p4.x, y : draw.p4.y};
			justTriangles_Draw.drawTri(id,true,q0,q31,q1,justTriangles_Draw.colorId);
			justTriangles_Draw.drawTri(id,true,q0,q31,q4,justTriangles_Draw.colorId);
			var p0_1 = p3[curveLen - 2];
			var p1_1 = p3[curveLen - 1];
			var draw2 = new justTriangles_Draw();
			draw2.p0 = p1_1;
			draw2.p1 = p0_1;
			draw2.halfA = Math.PI / 2;
			draw2._thick = thick;
			draw2.beta = Math.PI / 2 - draw2.halfA;
			draw2.r = draw2._thick / 2 * Math.cos(draw2.beta);
			draw2._theta = draw2.theta(draw2.p0,draw2.p1);
			if(draw2._theta > 0) {
				if(draw2.halfA < 0) {
					draw2.angle2 = draw2._theta + draw2.halfA + Math.PI / 2;
					draw2.angle1 = draw2._theta - draw2.halfA;
				} else {
					draw2.angle1 = draw2._theta + draw2.halfA - Math.PI;
					draw2.angle2 = draw2._theta + draw2.halfA;
				}
			} else if(draw2.halfA > 0) {
				draw2.angle1 = draw2._theta + draw2.halfA - Math.PI;
				draw2.angle2 = draw2._theta + draw2.halfA;
			} else {
				draw2.angle2 = draw2._theta + draw2.halfA + Math.PI / 2;
				draw2.angle1 = draw2._theta - draw2.halfA;
			}
			if(draw2.p3old != null) {
				draw2.p3old2 = draw2.p3old;
			}
			if(draw2.p4old != null) {
				draw2.p4old2 = draw2.p4old;
			}
			if(draw2.p3 != null) {
				draw2.p3old = draw2.p3;
			}
			if(draw2.p4 != null) {
				draw2.p4old = draw2.p4;
			}
			draw2.p3 = { x : draw2.p1.x + draw2.r * Math.cos(draw2.angle1), y : draw2.p1.y + draw2.r * Math.sin(draw2.angle1)};
			draw2.p4 = { x : draw2.p1.x + draw2.r * Math.cos(draw2.angle2), y : draw2.p1.y + draw2.r * Math.sin(draw2.angle2)};
			var q01 = { x : draw2.p3.x, y : draw2.p3.y};
			var q11 = { x : draw2.p4.x, y : draw2.p4.y};
			draw2.p0 = p0_1;
			draw2.p1 = p1_1;
			draw2._theta = draw2.theta(draw2.p0,draw2.p1);
			if(draw2._theta > 0) {
				if(draw2.halfA < 0) {
					draw2.angle2 = draw2._theta + draw2.halfA + Math.PI / 2;
					draw2.angle1 = draw2._theta - draw2.halfA;
				} else {
					draw2.angle1 = draw2._theta + draw2.halfA - Math.PI;
					draw2.angle2 = draw2._theta + draw2.halfA;
				}
			} else if(draw2.halfA > 0) {
				draw2.angle1 = draw2._theta + draw2.halfA - Math.PI;
				draw2.angle2 = draw2._theta + draw2.halfA;
			} else {
				draw2.angle2 = draw2._theta + draw2.halfA + Math.PI / 2;
				draw2.angle1 = draw2._theta - draw2.halfA;
			}
			if(draw2.p3old != null) {
				draw2.p3old2 = draw2.p3old;
			}
			if(draw2.p4old != null) {
				draw2.p4old2 = draw2.p4old;
			}
			if(draw2.p3 != null) {
				draw2.p3old = draw2.p3;
			}
			if(draw2.p4 != null) {
				draw2.p4old = draw2.p4;
			}
			draw2.p3 = { x : draw2.p1.x + draw2.r * Math.cos(draw2.angle1), y : draw2.p1.y + draw2.r * Math.sin(draw2.angle1)};
			draw2.p4 = { x : draw2.p1.x + draw2.r * Math.cos(draw2.angle2), y : draw2.p1.y + draw2.r * Math.sin(draw2.angle2)};
			var oldThickness1 = justTriangles_Draw.thickness;
			justTriangles_Draw.thickness = thick / 2;
			var temp1 = draw2.angle1 + Math.PI;
			var dx1 = p1_1.x;
			var dy1 = p1_1.y;
			var radius1 = thick / 4;
			var dA1 = Math.PI;
			var p5 = [];
			var angle1 = 0;
			var angleInc1 = Math.PI * 2 / 24;
			var nextAngle1;
			if(dA1 < 0) {
				var i3 = -1;
				while(true) {
					angle1 = i3 * angleInc1;
					--i3;
					nextAngle1 = angle1 + temp1;
					if(angle1 <= dA1) {
						break;
					}
					p5.push({ x : dx1 + radius1 * Math.cos(nextAngle1), y : dy1 + radius1 * Math.sin(nextAngle1)});
				}
			} else {
				var i4 = -1;
				while(true) {
					angle1 = i4 * angleInc1;
					++i4;
					nextAngle1 = angle1 + temp1;
					if(angle1 >= dA1 + angleInc1) {
						break;
					}
					p5.push({ x : dx1 + radius1 * Math.cos(nextAngle1), y : dy1 + radius1 * Math.sin(nextAngle1)});
				}
			}
			p5.reverse();
			justTriangles_Draw.q0 = p5[0];
			justTriangles_Draw.q1 = p5[0];
			var draw3 = new justTriangles_Draw();
			draw3.create2Lines(p5[0],p5[1],p5[2],justTriangles_Draw.thickness);
			justTriangles_Draw.q0 = draw3.p3;
			justTriangles_Draw.q1 = draw3.p4;
			var _g12 = 1;
			var _g2 = p5.length - 2;
			while(_g12 < _g2) {
				draw3.rebuildAsPoly(p5[_g12++ + 2]);
				var q32 = draw3.p3;
				justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q0,q32,p1_1,justTriangles_Draw.colorId);
				justTriangles_Draw.q0 = q32;
			}
			justTriangles_Draw.thickness = oldThickness1;
			var q33 = { x : draw2.p3.x, y : draw2.p3.y};
			var q41 = { x : draw2.p4.x, y : draw2.p4.y};
			justTriangles_Draw.drawTri(id,true,q01,q33,q11,justTriangles_Draw.colorId);
			justTriangles_Draw.drawTri(id,true,q01,q33,q41,justTriangles_Draw.colorId);
			justTriangles_Draw.q0 = p3[0];
			justTriangles_Draw.q1 = p3[0];
			var _g13 = 0;
			var _g3 = p3.length - 2;
			while(_g13 < _g3) {
				var i5 = _g13++;
				var draw4 = new justTriangles_Draw();
				draw4.create2Lines(p3[i5],p3[i5 + 1],p3[i5 + 2],justTriangles_Draw.thickness);
				var q34 = draw4.p3;
				var q42 = draw4.p4;
				if(i5 != 0) {
					justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q0,q34,justTriangles_Draw.q1,justTriangles_Draw.colorId);
					justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q1,q34,q42,justTriangles_Draw.colorId);
				}
				justTriangles_Draw.q0 = q34;
				justTriangles_Draw.q1 = q42;
			}
		}
	}
};
justTriangles_Draw.cubicCurves = function(id,p,thick) {
	var curveLen;
	var len = p.length - 1;
	var _g1 = 0;
	while(_g1 < len) {
		var i = _g1++;
		if((i - 2) % 3 == 0) {
			var p0 = p[i];
			var p1 = p[i + 1];
			var p2 = p[i + 2];
			var p3 = p[i + 3];
			var p4 = [];
			var x = p0.x - p1.x;
			var y = p0.y - p1.y;
			var x1 = p1.x - p2.x;
			var y1 = p1.y - p2.y;
			var x2 = p2.x - p3.x;
			var y2 = p2.y - p3.y;
			var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2);
			var v;
			if(approxDistance == 0) {
				approxDistance = 0.000001;
			}
			var step = Math.min(1 / (approxDistance * 0.707),justTriangles_ShapePoints.cubicStep);
			var t = 0.0;
			v = { x : Math.pow(1.,3) * p0.x + 3 * Math.pow(1.,2) * 0.0 * p1.x + 3. * Math.pow(0.0,2) * p2.x + Math.pow(0.0,3) * p3.x, y : Math.pow(1.,3) * p0.y + 3 * Math.pow(1.,2) * 0.0 * p1.y + 3. * Math.pow(0.0,2) * p2.y + Math.pow(0.0,3) * p3.y};
			p4.push({ x : v.x, y : v.y});
			t = step;
			while(t < 1) {
				var u = 1 - t;
				var u1 = 1 - t;
				v = { x : Math.pow(u,3) * p0.x + 3 * Math.pow(u,2) * t * p1.x + 3 * u * Math.pow(t,2) * p2.x + Math.pow(t,3) * p3.x, y : Math.pow(u1,3) * p0.y + 3 * Math.pow(u1,2) * t * p1.y + 3 * u1 * Math.pow(t,2) * p2.y + Math.pow(t,3) * p3.y};
				p4.push({ x : v.x, y : v.y});
				t += step;
			}
			v = { x : Math.pow(0.,3) * p0.x + 3 * Math.pow(0.,2) * p1.x + 0. * Math.pow(1.0,2) * p2.x + Math.pow(1.0,3) * p3.x, y : Math.pow(0.,3) * p0.y + 3 * Math.pow(0.,2) * p1.y + 0. * Math.pow(1.0,2) * p2.y + Math.pow(1.0,3) * p3.y};
			p4.push({ x : v.x, y : v.y});
			curveLen = p4.length;
			var p0_ = p4[0];
			var p1_ = p4[1];
			var draw = new justTriangles_Draw();
			draw.p0 = p1_;
			draw.p1 = p0_;
			draw.halfA = Math.PI / 2;
			draw._thick = thick;
			draw.beta = Math.PI / 2 - draw.halfA;
			draw.r = draw._thick / 2 * Math.cos(draw.beta);
			draw._theta = draw.theta(draw.p0,draw.p1);
			if(draw._theta > 0) {
				if(draw.halfA < 0) {
					draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
					draw.angle1 = draw._theta - draw.halfA;
				} else {
					draw.angle1 = draw._theta + draw.halfA - Math.PI;
					draw.angle2 = draw._theta + draw.halfA;
				}
			} else if(draw.halfA > 0) {
				draw.angle1 = draw._theta + draw.halfA - Math.PI;
				draw.angle2 = draw._theta + draw.halfA;
			} else {
				draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
				draw.angle1 = draw._theta - draw.halfA;
			}
			if(draw.p3old != null) {
				draw.p3old2 = draw.p3old;
			}
			if(draw.p4old != null) {
				draw.p4old2 = draw.p4old;
			}
			if(draw.p3 != null) {
				draw.p3old = draw.p3;
			}
			if(draw.p4 != null) {
				draw.p4old = draw.p4;
			}
			draw.p3 = { x : draw.p1.x + draw.r * Math.cos(draw.angle1), y : draw.p1.y + draw.r * Math.sin(draw.angle1)};
			draw.p4 = { x : draw.p1.x + draw.r * Math.cos(draw.angle2), y : draw.p1.y + draw.r * Math.sin(draw.angle2)};
			var q0 = { x : draw.p3.x, y : draw.p3.y};
			var q1 = { x : draw.p4.x, y : draw.p4.y};
			draw.p0 = p0_;
			draw.p1 = p1_;
			draw._theta = draw.theta(draw.p0,draw.p1);
			if(draw._theta > 0) {
				if(draw.halfA < 0) {
					draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
					draw.angle1 = draw._theta - draw.halfA;
				} else {
					draw.angle1 = draw._theta + draw.halfA - Math.PI;
					draw.angle2 = draw._theta + draw.halfA;
				}
			} else if(draw.halfA > 0) {
				draw.angle1 = draw._theta + draw.halfA - Math.PI;
				draw.angle2 = draw._theta + draw.halfA;
			} else {
				draw.angle2 = draw._theta + draw.halfA + Math.PI / 2;
				draw.angle1 = draw._theta - draw.halfA;
			}
			if(draw.p3old != null) {
				draw.p3old2 = draw.p3old;
			}
			if(draw.p4old != null) {
				draw.p4old2 = draw.p4old;
			}
			if(draw.p3 != null) {
				draw.p3old = draw.p3;
			}
			if(draw.p4 != null) {
				draw.p4old = draw.p4;
			}
			draw.p3 = { x : draw.p1.x + draw.r * Math.cos(draw.angle1), y : draw.p1.y + draw.r * Math.sin(draw.angle1)};
			draw.p4 = { x : draw.p1.x + draw.r * Math.cos(draw.angle2), y : draw.p1.y + draw.r * Math.sin(draw.angle2)};
			var oldThickness = justTriangles_Draw.thickness;
			justTriangles_Draw.thickness = thick / 2;
			var temp = draw.angle1;
			var dx = p0_.x;
			var dy = p0_.y;
			var radius = thick / 4;
			var dA = Math.PI;
			var p5 = [];
			var angle = 0;
			var angleInc = Math.PI * 2 / 24;
			var nextAngle;
			if(dA < 0) {
				var i1 = -1;
				while(true) {
					angle = i1 * angleInc;
					--i1;
					nextAngle = angle + temp;
					if(angle <= dA) {
						break;
					}
					p5.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
				}
			} else {
				var i2 = -1;
				while(true) {
					angle = i2 * angleInc;
					++i2;
					nextAngle = angle + temp;
					if(angle >= dA + angleInc) {
						break;
					}
					p5.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
				}
			}
			p5.reverse();
			justTriangles_Draw.q0 = p5[0];
			justTriangles_Draw.q1 = p5[0];
			var draw1 = new justTriangles_Draw();
			draw1.create2Lines(p5[0],p5[1],p5[2],justTriangles_Draw.thickness);
			justTriangles_Draw.q0 = draw1.p3;
			justTriangles_Draw.q1 = draw1.p4;
			var _g11 = 1;
			var _g = p5.length - 2;
			while(_g11 < _g) {
				draw1.rebuildAsPoly(p5[_g11++ + 2]);
				var q3 = draw1.p3;
				justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q0,q3,p0_,justTriangles_Draw.colorId);
				justTriangles_Draw.q0 = q3;
			}
			justTriangles_Draw.thickness = oldThickness;
			var q31 = { x : draw.p3.x, y : draw.p3.y};
			var q4 = { x : draw.p4.x, y : draw.p4.y};
			justTriangles_Draw.drawTri(id,true,q0,q31,q1,justTriangles_Draw.colorId);
			justTriangles_Draw.drawTri(id,true,q0,q31,q4,justTriangles_Draw.colorId);
			var p0_1 = p4[curveLen - 3];
			var p1_1 = p4[curveLen - 2];
			var draw2 = new justTriangles_Draw();
			draw2.p0 = p1_1;
			draw2.p1 = p0_1;
			draw2.halfA = Math.PI / 2;
			draw2._thick = thick;
			draw2.beta = Math.PI / 2 - draw2.halfA;
			draw2.r = draw2._thick / 2 * Math.cos(draw2.beta);
			draw2._theta = draw2.theta(draw2.p0,draw2.p1);
			if(draw2._theta > 0) {
				if(draw2.halfA < 0) {
					draw2.angle2 = draw2._theta + draw2.halfA + Math.PI / 2;
					draw2.angle1 = draw2._theta - draw2.halfA;
				} else {
					draw2.angle1 = draw2._theta + draw2.halfA - Math.PI;
					draw2.angle2 = draw2._theta + draw2.halfA;
				}
			} else if(draw2.halfA > 0) {
				draw2.angle1 = draw2._theta + draw2.halfA - Math.PI;
				draw2.angle2 = draw2._theta + draw2.halfA;
			} else {
				draw2.angle2 = draw2._theta + draw2.halfA + Math.PI / 2;
				draw2.angle1 = draw2._theta - draw2.halfA;
			}
			if(draw2.p3old != null) {
				draw2.p3old2 = draw2.p3old;
			}
			if(draw2.p4old != null) {
				draw2.p4old2 = draw2.p4old;
			}
			if(draw2.p3 != null) {
				draw2.p3old = draw2.p3;
			}
			if(draw2.p4 != null) {
				draw2.p4old = draw2.p4;
			}
			draw2.p3 = { x : draw2.p1.x + draw2.r * Math.cos(draw2.angle1), y : draw2.p1.y + draw2.r * Math.sin(draw2.angle1)};
			draw2.p4 = { x : draw2.p1.x + draw2.r * Math.cos(draw2.angle2), y : draw2.p1.y + draw2.r * Math.sin(draw2.angle2)};
			var q01 = { x : draw2.p3.x, y : draw2.p3.y};
			var q11 = { x : draw2.p4.x, y : draw2.p4.y};
			draw2.p0 = p0_1;
			draw2.p1 = p1_1;
			draw2._theta = draw2.theta(draw2.p0,draw2.p1);
			if(draw2._theta > 0) {
				if(draw2.halfA < 0) {
					draw2.angle2 = draw2._theta + draw2.halfA + Math.PI / 2;
					draw2.angle1 = draw2._theta - draw2.halfA;
				} else {
					draw2.angle1 = draw2._theta + draw2.halfA - Math.PI;
					draw2.angle2 = draw2._theta + draw2.halfA;
				}
			} else if(draw2.halfA > 0) {
				draw2.angle1 = draw2._theta + draw2.halfA - Math.PI;
				draw2.angle2 = draw2._theta + draw2.halfA;
			} else {
				draw2.angle2 = draw2._theta + draw2.halfA + Math.PI / 2;
				draw2.angle1 = draw2._theta - draw2.halfA;
			}
			if(draw2.p3old != null) {
				draw2.p3old2 = draw2.p3old;
			}
			if(draw2.p4old != null) {
				draw2.p4old2 = draw2.p4old;
			}
			if(draw2.p3 != null) {
				draw2.p3old = draw2.p3;
			}
			if(draw2.p4 != null) {
				draw2.p4old = draw2.p4;
			}
			draw2.p3 = { x : draw2.p1.x + draw2.r * Math.cos(draw2.angle1), y : draw2.p1.y + draw2.r * Math.sin(draw2.angle1)};
			draw2.p4 = { x : draw2.p1.x + draw2.r * Math.cos(draw2.angle2), y : draw2.p1.y + draw2.r * Math.sin(draw2.angle2)};
			var oldThickness1 = justTriangles_Draw.thickness;
			justTriangles_Draw.thickness = thick / 2;
			var temp1 = draw2.angle1 + Math.PI;
			var dx1 = p1_1.x;
			var dy1 = p1_1.y;
			var radius1 = thick / 4;
			var dA1 = Math.PI;
			var p6 = [];
			var angle1 = 0;
			var angleInc1 = Math.PI * 2 / 24;
			var nextAngle1;
			if(dA1 < 0) {
				var i3 = -1;
				while(true) {
					angle1 = i3 * angleInc1;
					--i3;
					nextAngle1 = angle1 + temp1;
					if(angle1 <= dA1) {
						break;
					}
					p6.push({ x : dx1 + radius1 * Math.cos(nextAngle1), y : dy1 + radius1 * Math.sin(nextAngle1)});
				}
			} else {
				var i4 = -1;
				while(true) {
					angle1 = i4 * angleInc1;
					++i4;
					nextAngle1 = angle1 + temp1;
					if(angle1 >= dA1 + angleInc1) {
						break;
					}
					p6.push({ x : dx1 + radius1 * Math.cos(nextAngle1), y : dy1 + radius1 * Math.sin(nextAngle1)});
				}
			}
			p6.reverse();
			justTriangles_Draw.q0 = p6[0];
			justTriangles_Draw.q1 = p6[0];
			var draw3 = new justTriangles_Draw();
			draw3.create2Lines(p6[0],p6[1],p6[2],justTriangles_Draw.thickness);
			justTriangles_Draw.q0 = draw3.p3;
			justTriangles_Draw.q1 = draw3.p4;
			var _g12 = 1;
			var _g2 = p6.length - 2;
			while(_g12 < _g2) {
				draw3.rebuildAsPoly(p6[_g12++ + 2]);
				var q32 = draw3.p3;
				justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q0,q32,p1_1,justTriangles_Draw.colorId);
				justTriangles_Draw.q0 = q32;
			}
			justTriangles_Draw.thickness = oldThickness1;
			var q33 = { x : draw2.p3.x, y : draw2.p3.y};
			var q41 = { x : draw2.p4.x, y : draw2.p4.y};
			justTriangles_Draw.drawTri(id,true,q01,q33,q11,justTriangles_Draw.colorId);
			justTriangles_Draw.drawTri(id,true,q01,q33,q41,justTriangles_Draw.colorId);
			justTriangles_Draw.q0 = p4[0];
			justTriangles_Draw.q1 = p4[0];
			var _g13 = 0;
			var _g3 = p4.length - 2;
			while(_g13 < _g3) {
				var i5 = _g13++;
				var draw4 = new justTriangles_Draw();
				draw4.create2Lines(p4[i5],p4[i5 + 1],p4[i5 + 2],justTriangles_Draw.thickness);
				var q34 = draw4.p3;
				var q42 = draw4.p4;
				if(i5 != 0) {
					justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q0,q34,justTriangles_Draw.q1,justTriangles_Draw.colorId);
					justTriangles_Draw.drawTri(id,true,justTriangles_Draw.q1,q34,q42,justTriangles_Draw.colorId);
				}
				justTriangles_Draw.q0 = q34;
				justTriangles_Draw.q1 = q42;
			}
		}
	}
};
justTriangles_Draw.dist = function(p0,p1) {
	var dx = p0.x - p1.x;
	var dy = p0.y - p1.y;
	return dx * dx + dy * dy;
};
justTriangles_Draw.poly = function(id,outline,p) {
	justTriangles_Draw.q0 = p[0];
	justTriangles_Draw.q1 = p[0];
	var draw = new justTriangles_Draw();
	draw.create2Lines(p[0],p[1],p[2],justTriangles_Draw.thickness);
	justTriangles_Draw.q0 = draw.p3;
	justTriangles_Draw.q1 = draw.p4;
	var _g1 = 1;
	var _g = p.length - 2;
	while(_g1 < _g) {
		draw.rebuildAsPoly(p[_g1++ + 2]);
		var q3 = draw.p3;
		var q4 = draw.p4;
		justTriangles_Draw.drawTri(id,outline,justTriangles_Draw.q0,q3,justTriangles_Draw.q1,justTriangles_Draw.colorId);
		justTriangles_Draw.drawTri(id,outline,justTriangles_Draw.q1,q3,q4,justTriangles_Draw.colorId);
		justTriangles_Draw.q0 = q3;
		justTriangles_Draw.q1 = q4;
	}
};
justTriangles_Draw.outerPoly = function(id,outline,centre,p) {
	justTriangles_Draw.q0 = p[0];
	justTriangles_Draw.q1 = p[0];
	var draw = new justTriangles_Draw();
	draw.create2Lines(p[0],p[1],p[2],justTriangles_Draw.thickness);
	justTriangles_Draw.q0 = draw.p3;
	justTriangles_Draw.q1 = draw.p4;
	var _g1 = 1;
	var _g = p.length - 2;
	while(_g1 < _g) {
		draw.rebuildAsPoly(p[_g1++ + 2]);
		var q3 = draw.p3;
		justTriangles_Draw.drawTri(id,outline,justTriangles_Draw.q0,q3,centre,justTriangles_Draw.colorId);
		justTriangles_Draw.q0 = q3;
	}
};
justTriangles_Draw.outerPolyExtra = function(id,outline,centre,p) {
	justTriangles_Draw.q0 = p[0];
	justTriangles_Draw.q1 = p[0];
	var draw = new justTriangles_Draw();
	draw.create2Lines(p[0],p[1],p[2],justTriangles_Draw.thickness);
	justTriangles_Draw.q0 = draw.p3;
	justTriangles_Draw.q1 = draw.p4;
	var _g1 = 1;
	var _g = p.length - 2;
	while(_g1 < _g) {
		draw.rebuildAsPoly(p[_g1++ + 2]);
		var q3 = draw.p3;
		justTriangles_Draw.drawTri(id,outline,justTriangles_Draw.q0,q3,centre,justTriangles_Draw.colorId);
		justTriangles_Draw.q0 = q3;
	}
};
justTriangles_Draw.innerPoly = function(id,outline,centre,p) {
	justTriangles_Draw.q0 = p[0];
	justTriangles_Draw.q1 = p[0];
	var draw = new justTriangles_Draw();
	draw.create2Lines(p[0],p[1],p[2],justTriangles_Draw.thickness);
	justTriangles_Draw.q0 = draw.p3;
	justTriangles_Draw.q1 = draw.p4;
	var _g1 = 1;
	var _g = p.length - 2;
	while(_g1 < _g) {
		draw.rebuildAsPoly(p[_g1++ + 2]);
		var q4 = draw.p4;
		justTriangles_Draw.drawTri(id,outline,justTriangles_Draw.q1,q4,centre,justTriangles_Draw.colorId);
		justTriangles_Draw.q1 = q4;
	}
};
justTriangles_Draw.triangles = function(id,outline,p) {
	justTriangles_Draw.q0 = p[0];
	justTriangles_Draw.q1 = p[0];
	var _g1 = 0;
	var _g = p.length - 2;
	while(_g1 < _g) {
		var i = _g1++;
		var draw = new justTriangles_Draw();
		draw.create2Lines(p[i],p[i + 1],p[i + 2],justTriangles_Draw.thickness);
		var q3 = draw.p3;
		var q4 = draw.p4;
		if(i != 0) {
			justTriangles_Draw.drawTri(id,outline,justTriangles_Draw.q0,q3,justTriangles_Draw.q1,justTriangles_Draw.colorId);
			justTriangles_Draw.drawTri(id,outline,justTriangles_Draw.q1,q3,q4,justTriangles_Draw.colorId);
		}
		justTriangles_Draw.q0 = q3;
		justTriangles_Draw.q1 = q4;
	}
};
justTriangles_Draw.firstQuad = function(id,p,i) {
	var draw = new justTriangles_Draw();
	draw.create2Lines(p[i],p[i + 1],p[i + 2],justTriangles_Draw.thickness);
	justTriangles_Draw.q0 = draw.p3;
	justTriangles_Draw.q1 = draw.p4;
	return draw;
};
justTriangles_Draw.otherQuad = function(id,outline,p,draw,i) {
	draw.rebuildAsPoly(p[i + 2]);
	var q3 = draw.p3;
	var q4 = draw.p4;
	justTriangles_Draw.drawTri(id,outline,justTriangles_Draw.q0,q3,justTriangles_Draw.q1,justTriangles_Draw.colorId);
	justTriangles_Draw.drawTri(id,outline,justTriangles_Draw.q1,q3,q4,justTriangles_Draw.colorId);
	justTriangles_Draw.q0 = q3;
	justTriangles_Draw.q1 = q4;
	return draw;
};
justTriangles_Draw.outerFilledTriangles = function(id,outline,centre,p,draw,i) {
	draw.rebuildAsPoly(p[i + 2]);
	var q3 = draw.p3;
	justTriangles_Draw.drawTri(id,outline,justTriangles_Draw.q0,q3,centre,justTriangles_Draw.colorId);
	justTriangles_Draw.q0 = q3;
	return draw;
};
justTriangles_Draw.outerFilledTrianglesExtra = function(id,outline,centre,p,draw,i) {
	draw.rebuildAsPoly(p[i + 2]);
	var q3 = draw.p3;
	justTriangles_Draw.drawTri(id,outline,justTriangles_Draw.q0,q3,centre,justTriangles_Draw.colorId);
	justTriangles_Draw.q0 = q3;
	return draw;
};
justTriangles_Draw.innerFilledTriangles = function(id,outline,centre,p,draw,i) {
	draw.rebuildAsPoly(p[i + 2]);
	var q4 = draw.p4;
	justTriangles_Draw.drawTri(id,outline,justTriangles_Draw.q1,q4,centre,justTriangles_Draw.colorId);
	justTriangles_Draw.q1 = q4;
	return draw;
};
justTriangles_Draw.quad = function(id,outline,p,i) {
	var draw = new justTriangles_Draw();
	draw.create2Lines(p[i],p[i + 1],p[i + 2],justTriangles_Draw.thickness);
	var q3 = draw.p3;
	var q4 = draw.p4;
	if(i != 0) {
		justTriangles_Draw.drawTri(id,outline,justTriangles_Draw.q0,q3,justTriangles_Draw.q1,justTriangles_Draw.colorId);
		justTriangles_Draw.drawTri(id,outline,justTriangles_Draw.q1,q3,q4,justTriangles_Draw.colorId);
	}
	justTriangles_Draw.q0 = q3;
	justTriangles_Draw.q1 = q4;
	return draw;
};
justTriangles_Draw.generateMidPoints = function(arr) {
	var out = [];
	var a;
	var b;
	var len = arr.length - 2;
	var _g1 = 0;
	while(_g1 < len) {
		var i = _g1++;
		a = arr[i];
		b = arr[i + 1];
		out.push({ x : (b.x + a.x) / 2, y : (b.y + a.y) / 2});
		out.push({ x : b.x, y : b.y});
	}
	a = arr[0];
	out.unshift({ x : a.x, y : a.y});
	out.unshift({ x : a.x, y : a.y});
	b = arr[arr.length - 1];
	out.push({ x : b.x, y : b.y});
	out.push({ x : b.x, y : b.y});
	out.push({ x : b.x, y : b.y});
	return out;
};
justTriangles_Draw.prototype = {
	create2Lines: function(p0_,p1_,p2_,thick) {
		this.p0 = p0_;
		this.p1 = p1_;
		this.p2 = p2_;
		this.b2 = justTriangles_Draw.dist(this.p0,this.p1);
		this.c2 = justTriangles_Draw.dist(this.p1,this.p2);
		this.a2 = justTriangles_Draw.dist(this.p0,this.p2);
		this.b = Math.sqrt(this.b2);
		this.c = Math.sqrt(this.c2);
		this.a = Math.sqrt(this.a2);
		this.cosA = (this.b2 + this.c2 - this.a2) / (2 * this.b * this.c);
		if(this.cosA > 1) {
			this.cosA = 1;
		} else if(this.cosA < -1) {
			this.cosA = -1;
		}
		this.angleA = Math.acos(this.cosA);
		this.halfA = this.angleA / 2;
		this._thick = thick;
		this.beta = Math.PI / 2 - this.halfA;
		this.r = this._thick / 2 * Math.cos(this.beta);
		this._theta = this.theta(this.p0,this.p1);
		if(this._theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this._theta + this.halfA + Math.PI / 2;
				this.angle1 = this._theta - this.halfA;
			} else {
				this.angle1 = this._theta + this.halfA - Math.PI;
				this.angle2 = this._theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this._theta + this.halfA - Math.PI;
			this.angle2 = this._theta + this.halfA;
		} else {
			this.angle2 = this._theta + this.halfA + Math.PI / 2;
			this.angle1 = this._theta - this.halfA;
		}
		if(this.p3old != null) {
			this.p3old2 = this.p3old;
		}
		if(this.p4old != null) {
			this.p4old2 = this.p4old;
		}
		if(this.p3 != null) {
			this.p3old = this.p3;
		}
		if(this.p4 != null) {
			this.p4old = this.p4;
		}
		this.p3 = { x : this.p1.x + this.r * Math.cos(this.angle1), y : this.p1.y + this.r * Math.sin(this.angle1)};
		this.p4 = { x : this.p1.x + this.r * Math.cos(this.angle2), y : this.p1.y + this.r * Math.sin(this.angle2)};
	}
	,setThickness: function(val) {
		this._thick = val;
		this.beta = Math.PI / 2 - this.halfA;
		this.r = this._thick / 2 * Math.cos(this.beta);
	}
	,calculateP3p4: function() {
		this._theta = this.theta(this.p0,this.p1);
		if(this._theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this._theta + this.halfA + Math.PI / 2;
				this.angle1 = this._theta - this.halfA;
			} else {
				this.angle1 = this._theta + this.halfA - Math.PI;
				this.angle2 = this._theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this._theta + this.halfA - Math.PI;
			this.angle2 = this._theta + this.halfA;
		} else {
			this.angle2 = this._theta + this.halfA + Math.PI / 2;
			this.angle1 = this._theta - this.halfA;
		}
		if(this.p3old != null) {
			this.p3old2 = this.p3old;
		}
		if(this.p4old != null) {
			this.p4old2 = this.p4old;
		}
		if(this.p3 != null) {
			this.p3old = this.p3;
		}
		if(this.p4 != null) {
			this.p4old = this.p4;
		}
		this.p3 = { x : this.p1.x + this.r * Math.cos(this.angle1), y : this.p1.y + this.r * Math.sin(this.angle1)};
		this.p4 = { x : this.p1.x + this.r * Math.cos(this.angle2), y : this.p1.y + this.r * Math.sin(this.angle2)};
	}
	,rebuildAsPoly: function(p2_) {
		this.p0 = this.p1;
		this.p1 = this.p2;
		this.p2 = p2_;
		this._theta = this.theta(this.p0,this.p1);
		if(this._theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this._theta + this.halfA + Math.PI / 2;
				this.angle1 = this._theta - this.halfA;
			} else {
				this.angle1 = this._theta + this.halfA - Math.PI;
				this.angle2 = this._theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this._theta + this.halfA - Math.PI;
			this.angle2 = this._theta + this.halfA;
		} else {
			this.angle2 = this._theta + this.halfA + Math.PI / 2;
			this.angle1 = this._theta - this.halfA;
		}
		if(this.p3old != null) {
			this.p3old2 = this.p3old;
		}
		if(this.p4old != null) {
			this.p4old2 = this.p4old;
		}
		if(this.p3 != null) {
			this.p3old = this.p3;
		}
		if(this.p4 != null) {
			this.p4old = this.p4;
		}
		this.p3 = { x : this.p1.x + this.r * Math.cos(this.angle1), y : this.p1.y + this.r * Math.sin(this.angle1)};
		this.p4 = { x : this.p1.x + this.r * Math.cos(this.angle2), y : this.p1.y + this.r * Math.sin(this.angle2)};
	}
	,theta: function(p0,p1) {
		return Math.atan2(p0.y - p1.y,p0.x - p1.x);
	}
};
var justTriangles_ShapePoints = function() { };
justTriangles_ShapePoints.__name__ = true;
justTriangles_ShapePoints.boxPoints = function(p,wid,hi) {
	return [{ x : p.x, y : p.y},{ x : p.x + wid, y : p.y},{ x : p.x + wid, y : p.y + hi},{ x : p.x, y : p.y + hi},{ x : p.x, y : p.y},{ x : p.x + wid, y : p.y},{ x : p.x + wid, y : p.y + hi}];
};
justTriangles_ShapePoints.box = function(x,y,wid,hi) {
	var p = [{ x : x, y : y},{ x : x + wid, y : y},{ x : x + wid, y : y + hi},{ x : x, y : y + hi},{ x : x, y : y},{ x : x + wid, y : y},{ x : x + wid, y : y + hi}];
	p.reverse();
	return p;
};
justTriangles_ShapePoints.equalTri = function(dx,dy,radius,rotation) {
	if(rotation == null) {
		rotation = 0;
	}
	var p = [];
	var angle = 0;
	var offset = -2.5 * Math.PI * 2 / 6 - Math.PI + rotation;
	var _g = 0;
	while(_g < 6) {
		angle = _g++ * (Math.PI * 2) / 3 - offset;
		p.push({ x : dx + radius * Math.cos(angle), y : dy + radius * Math.sin(angle)});
	}
	p.reverse();
	return p;
};
justTriangles_ShapePoints.polyPoints = function(d,radius,sides,rotation) {
	if(rotation == null) {
		rotation = 0;
	}
	var p = [];
	var angle = 0;
	var angleInc = Math.PI * 2 / sides;
	var offset = rotation - Math.PI / 2;
	var tot = sides + 3;
	var _g1 = 0;
	while(_g1 < tot) {
		var i = _g1++;
		angle = i * angleInc;
		angle += offset;
		p[tot - i - 1] = { x : d.x + radius * Math.cos(angle), y : d.y + radius * Math.sin(angle)};
	}
	return p;
};
justTriangles_ShapePoints.poly = function(dx,dy,radius,sides) {
	var p = [];
	var angle = 0;
	var angleInc = Math.PI * 2 / sides;
	var _g1 = 0;
	var _g = sides + 3;
	while(_g1 < _g) {
		angle = _g1++ * angleInc;
		p.push({ x : dx + radius * Math.cos(angle), y : dy + radius * Math.sin(angle)});
	}
	p.reverse();
	return p;
};
justTriangles_ShapePoints.horizontalWave = function(x_,dx_,y_,amplitude,sides,repeats) {
	var p = [];
	var dx = 0;
	var angleInc = Math.PI * 2 / sides;
	var len = sides * repeats | 0;
	var _g1 = 0;
	while(_g1 < len) p.push({ x : x_ + (dx += dx_), y : y_ + amplitude * Math.sin(_g1++ * angleInc)});
	return p;
};
justTriangles_ShapePoints.verticalWave = function(x_,y_,dy_,amplitude,sides,repeats) {
	var p = [];
	var dy = 0;
	var angleInc = Math.PI * 2 / sides;
	var len = sides * repeats | 0;
	var _g1 = 0;
	while(_g1 < len) p.push({ y : y_ + (dy += dy_), x : x_ + amplitude * Math.sin(_g1++ * angleInc)});
	return p;
};
justTriangles_ShapePoints.arcPoints = function(d,radius,start,dA,sides) {
	var p = [];
	var dx = d.x;
	var dy = d.y;
	var angle = 0;
	var angleInc = Math.PI * 2 / sides;
	var nextAngle;
	if(dA < 0) {
		var i = -1;
		while(true) {
			angle = i * angleInc;
			nextAngle = angle + start;
			--i;
			if(angle <= dA) {
				break;
			}
			p.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
		}
	} else {
		var i1 = -1;
		while(true) {
			angle = i1 * angleInc;
			++i1;
			nextAngle = angle + start;
			if(angle >= dA + angleInc) {
				break;
			}
			p.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
		}
	}
	return p;
};
justTriangles_ShapePoints.arc_internal = function(dx,dy,radius,start,dA,sides) {
	var p = [];
	var angle = 0;
	var angleInc = Math.PI * 2 / sides;
	var nextAngle;
	if(dA < 0) {
		var i = -1;
		while(true) {
			angle = i * angleInc;
			--i;
			nextAngle = angle + start;
			if(angle <= dA) {
				break;
			}
			p.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
		}
	} else {
		var i1 = -1;
		while(true) {
			angle = i1 * angleInc;
			++i1;
			nextAngle = angle + start;
			if(angle >= dA + angleInc) {
				break;
			}
			p.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
		}
		p.reverse();
	}
	return p;
};
justTriangles_ShapePoints.arc = function(dx,dy,radius,start,dA,sides) {
	var p = [];
	var angle = 0;
	var angleInc = Math.PI * 2 / sides;
	var nextAngle;
	if(dA < 0) {
		var i = -1;
		while(true) {
			angle = i * angleInc;
			--i;
			nextAngle = angle + start;
			if(angle <= dA) {
				break;
			}
			p.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
		}
	} else {
		var i1 = -1;
		while(true) {
			angle = i1 * angleInc;
			++i1;
			nextAngle = angle + start;
			if(angle >= dA + angleInc) {
				break;
			}
			p.push({ x : dx + radius * Math.cos(nextAngle), y : dy + radius * Math.sin(nextAngle)});
		}
	}
	p.reverse();
	return p;
};
justTriangles_ShapePoints.quadCurve = function(p0,p1,p2) {
	var p = [];
	var x = p0.x - p1.x;
	var y = p0.y - p1.y;
	var x1 = p1.x - p2.x;
	var y1 = p1.y - p2.y;
	var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
	var v;
	if(approxDistance == 0) {
		approxDistance = 0.000001;
	}
	var step = Math.min(1 / (approxDistance * 0.707),justTriangles_ShapePoints.quadStep);
	var t = 0.0;
	p.push(p0);
	t = step;
	while(t < 1) {
		var u = 1 - t;
		var u1 = 1 - t;
		v = { x : Math.pow(u,2) * p0.x + 2 * u * t * p1.x + Math.pow(t,2) * p2.x, y : Math.pow(u1,2) * p0.y + 2 * u1 * t * p1.y + Math.pow(t,2) * p2.y};
		p.push({ x : v.x, y : v.y});
		t += step;
	}
	p.push(p2);
	return p;
};
justTriangles_ShapePoints.cubicCurve = function(p0,p1,p2,p3) {
	var p = [];
	var x = p0.x - p1.x;
	var y = p0.y - p1.y;
	var x1 = p1.x - p2.x;
	var y1 = p1.y - p2.y;
	var x2 = p2.x - p3.x;
	var y2 = p2.y - p3.y;
	var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1) + Math.sqrt(x2 * x2 + y2 * y2);
	var v;
	if(approxDistance == 0) {
		approxDistance = 0.000001;
	}
	var step = Math.min(1 / (approxDistance * 0.707),justTriangles_ShapePoints.cubicStep);
	var t = 0.0;
	v = { x : Math.pow(1.,3) * p0.x + 3 * Math.pow(1.,2) * 0.0 * p1.x + 3. * Math.pow(0.0,2) * p2.x + Math.pow(0.0,3) * p3.x, y : Math.pow(1.,3) * p0.y + 3 * Math.pow(1.,2) * 0.0 * p1.y + 3. * Math.pow(0.0,2) * p2.y + Math.pow(0.0,3) * p3.y};
	p.push({ x : v.x, y : v.y});
	t = step;
	while(t < 1) {
		var u = 1 - t;
		var u1 = 1 - t;
		v = { x : Math.pow(u,3) * p0.x + 3 * Math.pow(u,2) * t * p1.x + 3 * u * Math.pow(t,2) * p2.x + Math.pow(t,3) * p3.x, y : Math.pow(u1,3) * p0.y + 3 * Math.pow(u1,2) * t * p1.y + 3 * u1 * Math.pow(t,2) * p2.y + Math.pow(t,3) * p3.y};
		p.push({ x : v.x, y : v.y});
		t += step;
	}
	v = { x : Math.pow(0.,3) * p0.x + 3 * Math.pow(0.,2) * p1.x + 0. * Math.pow(1.0,2) * p2.x + Math.pow(1.0,3) * p3.x, y : Math.pow(0.,3) * p0.y + 3 * Math.pow(0.,2) * p1.y + 0. * Math.pow(1.0,2) * p2.y + Math.pow(1.0,3) * p3.y};
	p.push({ x : v.x, y : v.y});
	return p;
};
justTriangles_ShapePoints.distance = function(p0,p1) {
	var x = p0.x - p1.x;
	var y = p0.y - p1.y;
	return Math.sqrt(x * x + y * y);
};
justTriangles_ShapePoints.quadraticBezier = function(t,arr) {
	var u = 1 - t;
	var u1 = 1 - t;
	return { x : Math.pow(u,2) * arr[0].x + 2 * u * t * arr[1].x + Math.pow(t,2) * arr[2].x, y : Math.pow(u1,2) * arr[0].y + 2 * u1 * t * arr[1].y + Math.pow(t,2) * arr[2].y};
};
justTriangles_ShapePoints._quadraticBezier = function(t,startPoint,controlPoint,endPoint) {
	var u = 1 - t;
	return Math.pow(u,2) * startPoint + 2 * u * t * controlPoint + Math.pow(t,2) * endPoint;
};
var justTriangles_Triangle = function(id_,outline_,A_,B_,C_,depth_,colorID_) {
	var p1_y;
	var p1_x;
	var p0_y;
	var p0_x;
	this.id = id_;
	this.outline = outline_;
	p0_x = B_.x - A_.x;
	p0_y = B_.y - A_.y;
	p1_x = C_.x - A_.x;
	p1_y = C_.y - A_.y;
	var val = !(p0_x * p1_y - p0_y * p1_x < 0);
	if(val) {
		this.ax = A_.x;
		this.ay = A_.y;
		this.bx = C_.x;
		this.by = C_.y;
		this.cx = B_.x;
		this.cy = B_.y;
	} else {
		this.ax = A_.x;
		this.ay = A_.y;
		this.bx = B_.x;
		this.by = B_.y;
		this.cx = C_.x;
		this.cy = C_.y;
	}
	this.windingAdjusted = val;
	this.depth = depth_;
	this.colorID = colorID_;
	this.colorA = colorID_;
	this.colorB = colorID_;
	this.colorC = colorID_;
};
justTriangles_Triangle.__name__ = true;
justTriangles_Triangle.drawTri = function(id,outline,p0,p1,p2,colorID) {
	justTriangles_Triangle.triangles.push(new justTriangles_Triangle(id,outline,p0,p1,p2,0,colorID));
};
justTriangles_Triangle.adjustWinding = function(A_,B_,C_) {
	return !((B_.x - A_.x) * (C_.y - A_.y) - (B_.y - A_.y) * (C_.x - A_.x) < 0);
};
justTriangles_Triangle.subtract = function(p0,p1) {
	return { x : p0.x - p1.x, y : p0.y - p1.y};
};
justTriangles_Triangle.cross = function(p0,p1) {
	return p0.x * p1.y - p0.y * p1.x;
};
justTriangles_Triangle.prototype = {
	get_x: function() {
		return Math.min(Math.min(this.ax,this.bx),this.cx);
	}
	,set_x: function(x) {
		var dx = x - this.get_x();
		this.ax += dx;
		this.bx += dx;
		this.cx += dx;
		return x;
	}
	,get_y: function() {
		return Math.min(Math.min(this.ay,this.by),this.cy);
	}
	,set_y: function(y) {
		var dy = y - this.get_y();
		this.ay += dy;
		this.by += dy;
		this.cy += dy;
		return y;
	}
	,get_right: function() {
		return Math.max(Math.max(this.ax,this.bx),this.cx);
	}
	,get_bottom: function() {
		return Math.max(Math.max(this.ay,this.by),this.cy);
	}
	,moveDelta: function(dx,dy) {
		this.ax += dx;
		this.ay += dy;
		this.bx += dx;
		this.by += dy;
		this.cx += dx;
		this.cy += dy;
	}
	,hitTest: function(P) {
		var px = P.x;
		var py = P.y;
		if(px > this.get_x() && px < this.get_right() && py > this.get_y() && py < this.get_bottom()) {
			return true;
		}
		var planeBC = (this.bx - px) * (this.cy - py) - (this.cx - px) * (this.by - py);
		if(this.sign((this.ax - px) * (this.by - py) - (this.bx - px) * (this.ay - py)) == this.sign(planeBC)) {
			return this.sign(planeBC) == this.sign((this.cx - px) * (this.ay - py) - (this.ax - px) * (this.cy - py));
		} else {
			return false;
		}
	}
	,sign: function(n) {
		return Math.abs(n) / n | 0;
	}
	,liteHit: function(px,py) {
		var planeBC = (this.bx - px) * (this.cy - py) - (this.cx - px) * (this.by - py);
		if(this.sign((this.ax - px) * (this.by - py) - (this.bx - px) * (this.ay - py)) == this.sign(planeBC)) {
			return this.sign(planeBC) == this.sign((this.cx - px) * (this.ay - py) - (this.ax - px) * (this.cy - py));
		} else {
			return false;
		}
	}
	,drawStrips: function(drawRect) {
		var xi = Math.floor(this.get_x());
		var righti = Math.ceil(this.get_right());
		var bottomi = Math.ceil(this.get_bottom());
		var sx = 0;
		var ex = 0;
		var sFound;
		var eFound;
		var _g1 = Math.floor(this.get_y());
		while(_g1 < bottomi) {
			var y0 = _g1++;
			sFound = false;
			eFound = false;
			var _g3 = xi;
			while(_g3 < righti) {
				var x0 = _g3++;
				var planeBC = (this.bx - x0) * (this.cy - y0) - (this.cx - x0) * (this.by - y0);
				if(this.sign((this.ax - x0) * (this.by - y0) - (this.bx - x0) * (this.ay - y0)) == this.sign(planeBC) && this.sign(planeBC) == this.sign((this.cx - x0) * (this.ay - y0) - (this.ax - x0) * (this.cy - y0))) {
					sx = x0;
					sFound = true;
					break;
				}
			}
			if(sFound) {
				var _g31 = sx;
				while(_g31 < righti) {
					var x01 = _g31++;
					var planeBC1 = (this.bx - x01) * (this.cy - y0) - (this.cx - x01) * (this.by - y0);
					if(!(this.sign((this.ax - x01) * (this.by - y0) - (this.bx - x01) * (this.ay - y0)) == this.sign(planeBC1) && this.sign(planeBC1) == this.sign((this.cx - x01) * (this.ay - y0) - (this.ax - x01) * (this.cy - y0)))) {
						ex = x01;
						eFound = true;
						break;
					}
				}
				if(eFound) {
					drawRect(sx,y0,ex - sx,1);
				}
			}
		}
	}
};
var tetrisTriangles_TetrisTrianglesSvg = function() {
	this.gameColors = [0,16711680,16744192,16776960,65280,255,4915330,9699539,4473924,3355443,789516,1118481];
	var this1;
	var svgElement = window.document.createElementNS("http://www.w3.org/2000/svg","svg");
	var element = svgElement;
	var style = element.style;
	style.paddingLeft = "0px";
	style.paddingTop = "0px";
	style.left = Std.string(0 + "px");
	style.top = Std.string(0 + "px");
	style.position = "absolute";
	window.document.body.appendChild(element);
	this1 = svgElement;
	var svgRoot = this1;
	svgRoot.setAttribute("width","1024");
	svgRoot.setAttribute("height","768");
	this.surface = new justDrawing_Surface(svgRoot);
	justTriangles_Draw.drawTri = justTriangles_Triangle.drawTri;
	this.tetrisTriangles = new tetrisTriangles_game_TetrisTriangles(1);
	if(htmlHelper_tools_AnimateTimer.s == null) {
		htmlHelper_tools_AnimateTimer.s = window.document.createElement("style");
		htmlHelper_tools_AnimateTimer.s.innerHTML = "@keyframes spin { from { transform:rotate( 0deg ); } to { transform:rotate( 360deg ); } }";
		window.document.getElementsByTagName("head")[0].appendChild(htmlHelper_tools_AnimateTimer.s);
		htmlHelper_tools_AnimateTimer.s.animation = "spin 1s linear infinite";
		htmlHelper_tools_AnimateTimer.loop(60.0);
	}
	htmlHelper_tools_AnimateTimer.onFrame = $bind(this,this.render);
};
tetrisTriangles_TetrisTrianglesSvg.__name__ = true;
tetrisTriangles_TetrisTrianglesSvg.main = function() {
	new tetrisTriangles_TetrisTrianglesSvg();
};
tetrisTriangles_TetrisTrianglesSvg.prototype = {
	render: function(i) {
		var _this = this.tetrisTriangles;
		var _this1 = _this.tetrisGenerator;
		_this1._points = _this1.horizontal.getPoints([]);
		var points = _this1._points;
		var pl = points.length;
		var tl = _this1.tetrisShapes.length;
		var count = -1;
		var _g1 = 0;
		while(_g1 < tl) {
			var i1 = _g1++;
			var _g3 = 0;
			while(_g3 < pl) if(_this1.tetrisShapes[i1].hitTest(points[_g3++])) {
				count = i1;
			}
		}
		if(count != -1) {
			var newBlocks = _this1.tetrisShapes[count].clearBlocks();
			var _g11 = 0;
			var _g = newBlocks.length;
			while(_g11 < _g) _this1.horizontal.pushBlock(newBlocks[_g11++]);
		}
		if(_this.count % 10 == 0) {
			_this.toggle = !_this.toggle;
		}
		_this.count += 1.;
		if(_this.toggle) {
			_this.count += 1.;
			var _this2 = _this.tetrisGenerator;
			var theta = Math.PI / 10;
			var _g12 = 0;
			var _g2 = _this2.tetrisShapes.length;
			while(_g12 < _g2) _this2.tetrisShapes[_g12++].rotate(theta);
		}
		var _this3 = _this.tetrisGenerator;
		var _g13 = 0;
		var _g4 = _this3.tetrisShapes.length;
		while(_g13 < _g4) _this3.tetrisShapes[_g13++].moveDelta(0.0,0.15);
		var _this4 = _this.tetrisGenerator;
		_this4._points = _this4.horizontal.getPoints([]);
		var points1 = _this4._points;
		var pl1 = points1.length;
		var tl1 = _this4.tetrisShapes.length;
		var count1 = -1;
		var _g14 = 0;
		while(_g14 < tl1) {
			var i2 = _g14++;
			var _g31 = 0;
			while(_g31 < pl1) if(_this4.tetrisShapes[i2].hitTest(points1[_g31++])) {
				count1 = i2;
			}
		}
		if(count1 != -1) {
			var newBlocks1 = _this4.tetrisShapes[count1].clearBlocks();
			var _g15 = 0;
			var _g5 = newBlocks1.length;
			while(_g15 < _g5) _this4.horizontal.pushBlock(newBlocks1[_g15++]);
		}
		var tri;
		var triangles = justTriangles_Triangle.triangles;
		var g = this.surface;
		g.beginFill(0,1.);
		g.lineStyle(0.,0,0.);
		g.drawRect(1,1,1022,766);
		g.endFill();
		var _g16 = 0;
		var _g6 = triangles.length;
		while(_g16 < _g6) {
			tri = triangles[_g16++];
			g.beginFill(this.gameColors[tri.colorID]);
			g.drawTri([200 + tri.ax * 300,200 + tri.ay * 300,200 + tri.bx * 300,200 + tri.by * 300,200 + tri.cx * 300,200 + tri.cy * 300]);
			g.endFill();
		}
	}
	,renderTriangles: function() {
		var tri;
		var triangles = justTriangles_Triangle.triangles;
		var g = this.surface;
		g.beginFill(0,1.);
		g.lineStyle(0.,0,0.);
		g.drawRect(1,1,1022,766);
		g.endFill();
		var _g1 = 0;
		var _g = triangles.length;
		while(_g1 < _g) {
			tri = triangles[_g1++];
			g.beginFill(this.gameColors[tri.colorID]);
			g.drawTri([200 + tri.ax * 300,200 + tri.ay * 300,200 + tri.bx * 300,200 + tri.by * 300,200 + tri.cx * 300,200 + tri.cy * 300]);
			g.endFill();
		}
	}
};
var tetrisTriangles_game_TetrisTriangles = function(scale) {
	if(scale == null) {
		scale = 1;
	}
	this.hi = 15;
	this.wide = 22;
	this.toggle = true;
	this.count = 0.;
	this.above = 7;
	this.right = 10;
	this.y = -4;
	this.x = -4;
	this.edge = 0.01;
	this.dia = 0.15;
	this.dia = scale * this.dia;
	this.edge = scale * this.edge;
	this.tetrisGenerator = new tetrisTriangles_visual_TetrisGenerator(0,justTriangles_Triangle.triangles,this.dia,this.edge);
	var dx = this.dia * this.x;
	var dy = this.dia * this.y;
	var sy = this.dia * this.above;
	this.tetrisGenerator.generateBackground({ x : dx, y : dy},this.wide,this.hi,10,0);
	var _g = 0;
	while(_g < 30) {
		var i = _g++;
		var m = i % 6;
		var randX = this.dia;
		var randX1 = this.dia;
		var randX2 = Math.random();
		this.tetrisGenerator.generateRandom({ x : dx + (randX + randX1 * Math.round(randX2 * (this.wide - 0.5))), y : dy - i * sy},m + 1,m + 2);
	}
	this.tetrisGenerator.generateHoriz({ x : dx, y : dy + this.dia * this.hi},this.wide,8,9);
};
tetrisTriangles_game_TetrisTriangles.__name__ = true;
tetrisTriangles_game_TetrisTriangles.prototype = {
	update: function() {
		var _this = this.tetrisGenerator;
		_this._points = _this.horizontal.getPoints([]);
		var points = _this._points;
		var pl = points.length;
		var tl = _this.tetrisShapes.length;
		var count = -1;
		var _g1 = 0;
		while(_g1 < tl) {
			var i = _g1++;
			var _g3 = 0;
			while(_g3 < pl) if(_this.tetrisShapes[i].hitTest(points[_g3++])) {
				count = i;
			}
		}
		if(count != -1) {
			var newBlocks = _this.tetrisShapes[count].clearBlocks();
			var _g11 = 0;
			var _g = newBlocks.length;
			while(_g11 < _g) _this.horizontal.pushBlock(newBlocks[_g11++]);
		}
		if(this.count % 10 == 0) {
			this.toggle = !this.toggle;
		}
		this.count += 1.;
		if(this.toggle) {
			this.count += 1.;
			var _this1 = this.tetrisGenerator;
			var theta = Math.PI / 10;
			var _g12 = 0;
			var _g2 = _this1.tetrisShapes.length;
			while(_g12 < _g2) _this1.tetrisShapes[_g12++].rotate(theta);
		}
		var _this2 = this.tetrisGenerator;
		var _g13 = 0;
		var _g4 = _this2.tetrisShapes.length;
		while(_g13 < _g4) _this2.tetrisShapes[_g13++].moveDelta(0.0,0.15);
		var _this3 = this.tetrisGenerator;
		_this3._points = _this3.horizontal.getPoints([]);
		var points1 = _this3._points;
		var pl1 = points1.length;
		var tl1 = _this3.tetrisShapes.length;
		var count1 = -1;
		var _g14 = 0;
		while(_g14 < tl1) {
			var i1 = _g14++;
			var _g31 = 0;
			while(_g31 < pl1) if(_this3.tetrisShapes[i1].hitTest(points1[_g31++])) {
				count1 = i1;
			}
		}
		if(count1 != -1) {
			var newBlocks1 = _this3.tetrisShapes[count1].clearBlocks();
			var _g15 = 0;
			var _g5 = newBlocks1.length;
			while(_g15 < _g5) _this3.horizontal.pushBlock(newBlocks1[_g15++]);
		}
	}
};
var tetrisTriangles_visual_Square = function(id,triangles,x_,y_,col0_id_,col1_id_,dia_,gap_) {
	this.dirtyY = false;
	this.dirtyX = false;
	this._x = x_;
	this._y = y_;
	this.col0_id = col0_id_;
	this.col1_id = col1_id_;
	this.dia = dia_;
	this.gap = 0.;
	this._x2 = x_ + dia_;
	this._y2 = y_ + dia_;
	var x2 = this._x2;
	var y2 = this._y2;
	var l = triangles.length;
	this.t0 = new justTriangles_Triangle(id,true,{ x : x_, y : y_},{ x : x2, y : y_},{ x : x_, y : y2},0,this.col0_id);
	this.t1 = new justTriangles_Triangle(id,true,{ x : x_, y : y2},{ x : x2, y : y_},{ x : x2, y : y2},0,this.col1_id);
	triangles[l++] = this.t0;
	triangles[l++] = this.t1;
};
tetrisTriangles_visual_Square.__name__ = true;
tetrisTriangles_visual_Square.prototype = {
	getPoints: function(arr) {
		var l = arr.length;
		arr[l++] = { x : this.t0.ax, y : this.t0.ay};
		arr[l++] = { x : this.t0.bx, y : this.t0.by};
		arr[l++] = { x : this.t0.cx, y : this.t0.cy};
		arr[l++] = { x : this.t1.ax, y : this.t1.ay};
		arr[l++] = { x : this.t1.bx, y : this.t1.by};
		arr[l++] = { x : this.t1.cx, y : this.t1.cy};
		return arr;
	}
	,moveDelta: function(dx,dy) {
		this.t0.moveDelta(dx,dy);
		this.t1.moveDelta(dx,dy);
	}
	,rotateAroundTheta: function(p,theta) {
		var cos = Math.cos(theta);
		var sin = Math.sin(theta);
		var t = this.t0;
		this.dirtyX = true;
		this.dirtyY = true;
		t.moveDelta(-p.x,-p.y);
		t.moveDelta(-p.x,-p.y);
		var x;
		var y;
		x = t.ax;
		y = t.ay;
		t.ax = x * cos - y * sin;
		t.ay = x * sin + y * cos;
		x = t.bx;
		y = t.by;
		t.bx = x * cos - y * sin;
		t.by = x * sin + y * cos;
		x = t.cx;
		y = t.cy;
		t.cx = x * cos - y * sin;
		t.cy = x * sin + y * cos;
		t.moveDelta(p.x,p.y);
		t.moveDelta(p.x,p.y);
		this.dirtyX = true;
		this.dirtyY = true;
		var t1 = this.t1;
		this.dirtyX = true;
		this.dirtyY = true;
		t1.moveDelta(-p.x,-p.y);
		t1.moveDelta(-p.x,-p.y);
		var x1;
		var y1;
		x1 = t1.ax;
		y1 = t1.ay;
		t1.ax = x1 * cos - y1 * sin;
		t1.ay = x1 * sin + y1 * cos;
		x1 = t1.bx;
		y1 = t1.by;
		t1.bx = x1 * cos - y1 * sin;
		t1.by = x1 * sin + y1 * cos;
		x1 = t1.cx;
		y1 = t1.cy;
		t1.cx = x1 * cos - y1 * sin;
		t1.cy = x1 * sin + y1 * cos;
		t1.moveDelta(p.x,p.y);
		t1.moveDelta(p.x,p.y);
		this.dirtyX = true;
		this.dirtyY = true;
	}
	,rotateAround: function(p,cos,sin) {
		var t = this.t0;
		this.dirtyX = true;
		this.dirtyY = true;
		t.moveDelta(-p.x,-p.y);
		t.moveDelta(-p.x,-p.y);
		var x;
		var y;
		x = t.ax;
		y = t.ay;
		t.ax = x * cos - y * sin;
		t.ay = x * sin + y * cos;
		x = t.bx;
		y = t.by;
		t.bx = x * cos - y * sin;
		t.by = x * sin + y * cos;
		x = t.cx;
		y = t.cy;
		t.cx = x * cos - y * sin;
		t.cy = x * sin + y * cos;
		t.moveDelta(p.x,p.y);
		t.moveDelta(p.x,p.y);
		this.dirtyX = true;
		this.dirtyY = true;
		var t1 = this.t1;
		this.dirtyX = true;
		this.dirtyY = true;
		t1.moveDelta(-p.x,-p.y);
		t1.moveDelta(-p.x,-p.y);
		var x1;
		var y1;
		x1 = t1.ax;
		y1 = t1.ay;
		t1.ax = x1 * cos - y1 * sin;
		t1.ay = x1 * sin + y1 * cos;
		x1 = t1.bx;
		y1 = t1.by;
		t1.bx = x1 * cos - y1 * sin;
		t1.by = x1 * sin + y1 * cos;
		x1 = t1.cx;
		y1 = t1.cy;
		t1.cx = x1 * cos - y1 * sin;
		t1.cy = x1 * sin + y1 * cos;
		t1.moveDelta(p.x,p.y);
		t1.moveDelta(p.x,p.y);
		this.dirtyX = true;
		this.dirtyY = true;
	}
	,rotateTriangle: function(t,p,cos,sin) {
		this.dirtyX = true;
		this.dirtyY = true;
		t.moveDelta(-p.x,-p.y);
		t.moveDelta(-p.x,-p.y);
		var x;
		var y;
		x = t.ax;
		y = t.ay;
		t.ax = x * cos - y * sin;
		t.ay = x * sin + y * cos;
		x = t.bx;
		y = t.by;
		t.bx = x * cos - y * sin;
		t.by = x * sin + y * cos;
		x = t.cx;
		y = t.cy;
		t.cx = x * cos - y * sin;
		t.cy = x * sin + y * cos;
		t.moveDelta(p.x,p.y);
		t.moveDelta(p.x,p.y);
		this.dirtyX = true;
		this.dirtyY = true;
	}
	,get_right: function() {
		return Math.max(this.t0.get_right(),this.t1.get_right());
	}
	,get_bottom: function() {
		return Math.max(this.t0.get_bottom(),this.t1.get_bottom());
	}
	,get_x: function() {
		if(this.dirtyX) {
			return Math.min(this.t0.get_x(),this.t1.get_x());
		} else {
			return this._x;
		}
	}
	,set_x: function(x) {
		var x0 = this.t0.get_x();
		var x1 = this.t1.get_x();
		if(x0 < x1) {
			this.t0.set_x(x);
			this.t1.set_x(x + (x0 - x));
		} else {
			this.t0.set_x(x + (x1 - x));
			this.t1.set_x(x);
		}
		this._x = x;
		this.dirtyX = false;
		return x;
	}
	,get_y: function() {
		if(this.dirtyY) {
			return Math.min(this.t0.get_y(),this.t1.get_y());
		} else {
			return this._y;
		}
	}
	,set_y: function(y) {
		var y0 = this.t0.get_y();
		var y1 = this.t1.get_y();
		if(y0 < y1) {
			this.t0.set_y(y);
			this.t1.set_y(y + (y0 - y));
		} else {
			this.t0.set_y(y + (y1 - y));
			this.t1.set_y(y);
		}
		this.dirtyY = false;
		this._y = y;
		return y;
	}
	,hitTest: function(p) {
		if(!this.t0.hitTest(p)) {
			return this.t1.hitTest(p);
		} else {
			return true;
		}
	}
};
var tetrisTriangles_visual_TetrisGenerator = function(id_,triangles_,dia_,gap_) {
	this.last = -1;
	this.col1_id = 5;
	this.col0_id = 1;
	this.tetrisShapes = [];
	this.id = id_;
	this.triangles = triangles_;
	this.dia = dia_;
	this.gap = gap_;
};
tetrisTriangles_visual_TetrisGenerator.__name__ = true;
tetrisTriangles_visual_TetrisGenerator.prototype = {
	generateRandom: function(p,col0_id_,col1_id_) {
		this.col0_id = col0_id_;
		this.col1_id = col1_id_;
		var random = Math.round(4 * Math.random());
		if(random == this.last) {
			this.generateRandom(p,this.col0_id,this.col1_id);
			return;
		}
		var tmp = this.tetrisShapes;
		var tmp1 = this.tetrisShapes.length;
		var tmp2;
		switch(random) {
		case 0:
			tmp2 = this.generate_S(p);
			break;
		case 1:
			tmp2 = this.generate_l(p);
			break;
		case 2:
			tmp2 = this.generate_box(p);
			break;
		case 3:
			tmp2 = this.generate_L(p);
			break;
		case 4:
			tmp2 = this.generate_t(p);
			break;
		default:
			tmp2 = this.generate_l(p);
		}
		tmp[tmp1] = tmp2;
		this.last = random;
	}
	,hitBottom: function() {
		this._points = this.horizontal.getPoints([]);
		var points = this._points;
		var pl = points.length;
		var tl = this.tetrisShapes.length;
		var count = -1;
		var _g1 = 0;
		while(_g1 < tl) {
			var i = _g1++;
			var _g3 = 0;
			while(_g3 < pl) if(this.tetrisShapes[i].hitTest(points[_g3++])) {
				count = i;
			}
		}
		if(count != -1) {
			var newBlocks = this.tetrisShapes[count].clearBlocks();
			var _g11 = 0;
			var _g = newBlocks.length;
			while(_g11 < _g) this.horizontal.pushBlock(newBlocks[_g11++]);
		}
	}
	,rotate: function(theta) {
		var _g1 = 0;
		var _g = this.tetrisShapes.length;
		while(_g1 < _g) this.tetrisShapes[_g1++].rotate(theta);
	}
	,moveDelta: function(x,y) {
		var _g1 = 0;
		var _g = this.tetrisShapes.length;
		while(_g1 < _g) this.tetrisShapes[_g1++].moveDelta(x,y);
	}
	,createTetris: function(p) {
		return new tetrisTriangles_visual_TetrisShape(this.id,this.triangles,p,this.col0_id,this.col1_id,this.dia,this.gap);
	}
	,generate_S: function(p) {
		var ts = new tetrisTriangles_visual_TetrisShape(this.id,this.triangles,p,this.col0_id,this.col1_id,this.dia,this.gap);
		ts.addBlock(-0.5,-1);
		ts.addBlock(0.5,0);
		ts.addBlock(0.5,-1);
		ts.addBlock(1.5,0);
		return ts;
	}
	,generate_l: function(p) {
		var ts = new tetrisTriangles_visual_TetrisShape(this.id,this.triangles,p,this.col0_id,this.col1_id,this.dia,this.gap);
		ts.addBlock(-0.5,-2);
		ts.addBlock(-0.5,-1);
		ts.addBlock(-0.5,0);
		ts.addBlock(-0.5,1);
		return ts;
	}
	,generate_box: function(p) {
		var ts = new tetrisTriangles_visual_TetrisShape(this.id,this.triangles,p,this.col0_id,this.col1_id,this.dia,this.gap);
		ts.addBlock(-1,-1);
		ts.addBlock(0,-1);
		ts.addBlock(-1,0);
		ts.addBlock(0,0);
		return ts;
	}
	,generate_L: function(p) {
		var ts = new tetrisTriangles_visual_TetrisShape(this.id,this.triangles,p,this.col0_id,this.col1_id,this.dia,this.gap);
		ts.addBlock(-1,-1.5);
		ts.addBlock(-1,-0.5);
		ts.addBlock(-1,0.5);
		ts.addBlock(0,0.5);
		return ts;
	}
	,generate_t: function(p) {
		var ts = new tetrisTriangles_visual_TetrisShape(this.id,this.triangles,p,this.col0_id,this.col1_id,this.dia,this.gap);
		ts.addBlock(-1,-1.5);
		ts.addBlock(-1,-0.5);
		ts.addBlock(-1,0.5);
		ts.addBlock(0,-0.5);
		return ts;
	}
	,generateBackground: function(p,wide,hi,col0_id_,col1_id_) {
		this.col0_id = col0_id_;
		this.col1_id = col1_id_;
		var ts = new tetrisTriangles_visual_TetrisShape(this.id,this.triangles,p,this.col0_id,this.col1_id,this.dia,this.gap);
		var _g1 = 0;
		while(_g1 < wide) {
			var w = _g1++;
			var _g3 = 0;
			while(_g3 < hi) ts.addBlock(w,_g3++);
		}
		this.background = ts;
	}
	,generateHoriz: function(p,wide,col0_id_,col1_id_) {
		this.col0_id = col0_id_;
		this.col1_id = col1_id_;
		var ts = new tetrisTriangles_visual_TetrisShape(this.id,this.triangles,p,this.col0_id,this.col1_id,this.dia,this.gap);
		var _g1 = 0;
		while(_g1 < wide) ts.addBlock(_g1++,0);
		this.horizontal = ts;
	}
};
var tetrisTriangles_visual_TetrisShape = function(id_,triangles_,centre_,col0_id_,col1_id_,dia_,gap_) {
	this.centre = centre_;
	this.id = id_;
	this.triangles = triangles_;
	this.col0_id = col0_id_;
	this.col1_id = col1_id_;
	this.dia = dia_;
	this.gap = gap_;
	this.blocks = [];
};
tetrisTriangles_visual_TetrisShape.__name__ = true;
tetrisTriangles_visual_TetrisShape.prototype = {
	addBlock: function(x_,y_) {
		this.blocks[this.blocks.length] = new tetrisTriangles_visual_Square(this.id,this.triangles,x_ * this.dia + this.centre.x,y_ * this.dia + this.centre.y,this.col0_id,this.col1_id,this.dia,this.gap);
	}
	,pushBlock: function(square) {
		this.blocks[this.blocks.length] = square;
	}
	,clearBlocks: function() {
		var newBlocks = [];
		var _g1 = 0;
		var _g = this.blocks.length;
		while(_g1 < _g) {
			var i = _g1++;
			newBlocks[i] = this.blocks[i];
		}
		this.blocks = [];
		return newBlocks;
	}
	,rotate: function(theta) {
		var l = this.blocks.length;
		var cos = Math.cos(theta);
		var sin = Math.sin(theta);
		var _g1 = 0;
		while(_g1 < l) {
			var i = _g1++;
			this.blocks[i].moveDelta(this.centre.x,this.centre.y);
			var _this = this.blocks[i];
			var p = this.centre;
			var t = _this.t0;
			_this.dirtyX = true;
			_this.dirtyY = true;
			t.moveDelta(-p.x,-p.y);
			t.moveDelta(-p.x,-p.y);
			var x;
			var y;
			x = t.ax;
			y = t.ay;
			t.ax = x * cos - y * sin;
			t.ay = x * sin + y * cos;
			x = t.bx;
			y = t.by;
			t.bx = x * cos - y * sin;
			t.by = x * sin + y * cos;
			x = t.cx;
			y = t.cy;
			t.cx = x * cos - y * sin;
			t.cy = x * sin + y * cos;
			t.moveDelta(p.x,p.y);
			t.moveDelta(p.x,p.y);
			_this.dirtyX = true;
			_this.dirtyY = true;
			var t1 = _this.t1;
			_this.dirtyX = true;
			_this.dirtyY = true;
			t1.moveDelta(-p.x,-p.y);
			t1.moveDelta(-p.x,-p.y);
			var x1;
			var y1;
			x1 = t1.ax;
			y1 = t1.ay;
			t1.ax = x1 * cos - y1 * sin;
			t1.ay = x1 * sin + y1 * cos;
			x1 = t1.bx;
			y1 = t1.by;
			t1.bx = x1 * cos - y1 * sin;
			t1.by = x1 * sin + y1 * cos;
			x1 = t1.cx;
			y1 = t1.cy;
			t1.cx = x1 * cos - y1 * sin;
			t1.cy = x1 * sin + y1 * cos;
			t1.moveDelta(p.x,p.y);
			t1.moveDelta(p.x,p.y);
			_this.dirtyX = true;
			_this.dirtyY = true;
			this.blocks[i].moveDelta(-this.centre.x,-this.centre.y);
		}
	}
	,getPoints: function(points) {
		var l = this.blocks.length;
		var _g1 = 0;
		while(_g1 < l) this.blocks[_g1++].getPoints(points);
		return points;
	}
	,moveDelta: function(dx,dy) {
		this.centre.x += dx;
		this.centre.y += dy;
		var l = this.blocks.length;
		var _g1 = 0;
		while(_g1 < l) this.blocks[_g1++].moveDelta(dx,dy);
	}
	,hitTest: function(p) {
		var out = false;
		var l = this.blocks.length;
		var _g1 = 0;
		while(_g1 < l) if(this.blocks[_g1++].hitTest(p)) {
			out = true;
		}
		return out;
	}
};
var $_, $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = function(){ return f.method.apply(f.scope, arguments); }; f.scope = o; f.method = m; o.hx__closures__[m.__id__] = f; } return f; }
String.__name__ = true;
Array.__name__ = true;
htmlHelper_svg__$SvgRoot_SvgRoot_$Impl_$.svgNameSpace = "http://www.w3.org/2000/svg";
htmlHelper_tools_AnimateTimer.counter = 0;
justDrawing_Surface.svgNameSpace = "http://www.w3.org/2000/svg";
justDrawing_Surface.cubicStep = 0.03;
justTriangles_Draw.circleSides = 60;
justTriangles_ShapePoints.quadStep = 0.03;
justTriangles_ShapePoints.cubicStep = 0.03;
justTriangles_Triangle.triangles = [];
tetrisTriangles_TetrisTrianglesSvg.main();
})();
